{
  "version": 3,
  "sources": ["../node_modules/webgpu-radix-sort/src/shaders/prefix_sum.js", "../node_modules/webgpu-radix-sort/src/shaders/optimizations/prefix_sum_no_bank_conflict.js", "../node_modules/webgpu-radix-sort/src/utils.js", "../node_modules/webgpu-radix-sort/src/PrefixSumKernel.js", "../node_modules/webgpu-radix-sort/src/shaders/radix_sort.js", "../node_modules/webgpu-radix-sort/src/shaders/optimizations/radix_sort_local_shuffle.js", "../node_modules/webgpu-radix-sort/src/shaders/radix_sort_reorder.js", "../node_modules/webgpu-radix-sort/src/shaders/check_sort.js", "../node_modules/webgpu-radix-sort/src/CheckSortKernel.js", "../node_modules/webgpu-radix-sort/src/RadixSortKernel.js", "../src/ts/render/shaders.ts", "../src/ts/render/square.ts", "../node_modules/src/types.ts", "../node_modules/src/utils.ts", "../node_modules/src/vec2-impl.ts", "../node_modules/src/vec3-impl.ts", "../node_modules/src/mat3-impl.ts", "../node_modules/src/mat4-impl.ts", "../node_modules/src/quat-impl.ts", "../node_modules/src/vec4-impl.ts", "../node_modules/src/wgpu-matrix.ts", "../src/ts/common.ts", "../src/ts/render/renderer.ts", "../src/ts/compute/shader/grid/gridAccess.ts", "../src/ts/compute/shader/shaderLayout.ts", "../src/ts/compute/shader/grid/assignCell.ts", "../src/ts/compute/shader/grid/createStructure.ts", "../src/ts/compute/shader/physics/sph.ts", "../src/ts/compute/shader/update1.ts", "../src/ts/compute/shader/physics/sdf.ts", "../src/ts/compute/shader/update2.ts", "../src/ts/compute/computer.ts", "../src/ts/scene.ts", "../src/main.ts"],
  "sourcesContent": ["const prefixSumSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    temp[ELM_TID]     = select(items[ELM_GID], 0, ELM_GID >= ELEMENT_COUNT);\r\n    temp[ELM_TID + 1] = select(items[ELM_GID + 1], 0, ELM_GID + 1 >= ELEMENT_COUNT);\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    if (ELM_GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n    items[ELM_GID] = temp[ELM_TID];\r\n\r\n    if (ELM_GID + 1 >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n\r\n    if (ELM_ID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n\r\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumSource", "/**\r\n * Prefix sum with optimization to avoid bank conflicts\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst prefixSumNoBankConflictSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nconst NUM_BANKS: u32 = 32;\r\nconst LOG_NUM_BANKS: u32 = 5;\r\n\r\nfn get_offset(offset: u32) -> u32 {\r\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\r\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\r\n}\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    let ai: u32 = TID;\r\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\r\n    let s_ai = ai + get_offset(ai);\r\n    let s_bi = bi + get_offset(bi);\r\n    let g_ai = ai + WID * 2;\r\n    let g_bi = bi + WID * 2;\r\n    temp[s_ai] = select(items[g_ai], 0, g_ai >= ELEMENT_COUNT);\r\n    temp[s_bi] = select(items[g_bi], 0, g_bi >= ELEMENT_COUNT);\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\r\n        last_offset += get_offset(last_offset);\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    if (g_ai < ELEMENT_COUNT) {\r\n        items[g_ai] = temp[s_ai];\r\n    }\r\n    if (g_bi < ELEMENT_COUNT) {\r\n        items[g_bi] = temp[s_bi];\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n\r\n    if (ELM_ID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n\r\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumNoBankConflictSource", "/**\r\n * Find the best dispatch size x and y dimensions to minimize unused workgroups\r\n * \r\n * @param {GPUDevice} device - The GPU device\r\n * @param {int} workgroup_count - Number of workgroups to dispatch\r\n * @returns \r\n */\r\nfunction find_optimal_dispatch_size(device, workgroup_count) {\r\n    const dispatchSize = { \r\n        x: workgroup_count, \r\n        y: 1\r\n    }\r\n\r\n    if (workgroup_count > device.limits.maxComputeWorkgroupsPerDimension) {\r\n        const x = Math.floor(Math.sqrt(workgroup_count))\r\n        const y = Math.ceil(workgroup_count / x)\r\n        \r\n        dispatchSize.x = x\r\n        dispatchSize.y = y\r\n    }\r\n\r\n    return dispatchSize\r\n}\r\n\r\nfunction create_buffer_from_data({device, label, data, usage = 0}) {\r\n    const dispatchSizes = device.createBuffer({\r\n        label: label,\r\n        usage: usage,\r\n        size: data.length * 4,\r\n        mappedAtCreation: true\r\n    })\r\n\r\n    const dispatchData = new Uint32Array(dispatchSizes.getMappedRange())\r\n    dispatchData.set(data)\r\n    dispatchSizes.unmap()\r\n\r\n    return dispatchSizes\r\n}\r\n\r\nexport {\r\n    find_optimal_dispatch_size,\r\n    create_buffer_from_data,\r\n}", "import prefixSumSource from \"./shaders/prefix_sum\"\r\nimport prefixSumSource_NoBankConflict from \"./shaders/optimizations/prefix_sum_no_bank_conflict\"\r\nimport { find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass PrefixSumKernel {\r\n    /**\r\n     * Perform a parallel prefix sum on the given data buffer\r\n     * \r\n     * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\r\n     * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - Buffer containing the data to process\r\n     * @param {number} count - Max number of elements to process\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} avoid_bank_conflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        count,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        avoid_bank_conflicts = false\r\n    }) {\r\n        this.device = device\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.items_per_workgroup = 2 * this.threads_per_workgroup // 2 items are processed per thread\r\n\r\n        if (Math.log2(this.threads_per_workgroup) % 1 !== 0) \r\n            throw new Error(`workgroup_size.x * workgroup_size.y must be a power of two. (current: ${this.threads_per_workgroup})`)\r\n\r\n        this.pipelines = []\r\n\r\n        this.shaderModule = this.device.createShaderModule({\r\n            label: 'prefix-sum',\r\n            code: avoid_bank_conflicts ? prefixSumSource_NoBankConflict : prefixSumSource,\r\n        })\r\n\r\n        this.create_pass_recursive(data, count)\r\n    }\r\n\r\n    create_pass_recursive(data, count) {\r\n        // Find best dispatch x and y dimensions to minimize unused threads\r\n        const workgroup_count = Math.ceil(count / this.items_per_workgroup)\r\n        const dispatchSize = find_optimal_dispatch_size(this.device, workgroup_count)\r\n        \r\n        // Create buffer for block sums        \r\n        const blockSumBuffer = this.device.createBuffer({\r\n            label: 'prefix-sum-block-sum',\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create bind group and pipeline layout\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            label: 'prefix-sum-bind-group',\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: data }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: blockSumBuffer }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        // Per-workgroup (block) prefix sum\r\n        const scanPipeline = this.device.createComputePipeline({\r\n            label: 'prefix-sum-scan-pipeline',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModule,\r\n                entryPoint: 'reduce_downsweep',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ITEMS_PER_WORKGROUP': this.items_per_workgroup,\r\n                    'ELEMENT_COUNT': count,\r\n                }\r\n            }\r\n        })\r\n\r\n        this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize })\r\n\r\n        if (workgroup_count > 1) {\r\n            // Prefix sum on block sums\r\n            this.create_pass_recursive(blockSumBuffer, workgroup_count)\r\n\r\n            // Add block sums to local prefix sums\r\n            const blockSumPipeline = this.device.createComputePipeline({\r\n                label: 'prefix-sum-add-block-pipeline',\r\n                layout: pipelineLayout,\r\n                compute: {\r\n                    module: this.shaderModule,\r\n                    entryPoint: 'add_block_sums',\r\n                    constants: {\r\n                        'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                        'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                        'ELEMENT_COUNT': count,\r\n                    }\r\n                }\r\n            })\r\n\r\n            this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize })\r\n        }\r\n    }\r\n\r\n    get_dispatch_chain() {\r\n        return this.pipelines.flatMap(p => [ p.dispatchSize.x, p.dispatchSize.y, 1 ])\r\n    }\r\n\r\n    /**\r\n     * Encode the prefix sum pipeline into the current pass.\r\n     * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\r\n     * @param {int} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\r\n     */\r\n    dispatch(pass, dispatchSizeBuffer, offset = 0) {\r\n        for (let i = 0; i < this.pipelines.length; i++) {\r\n            const { pipeline, bindGroup, dispatchSize } = this.pipelines[i]\r\n            \r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n\r\n            if (dispatchSizeBuffer == null)\r\n                pass.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, 1)\r\n            else\r\n                pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4)\r\n        }\r\n    }\r\n}\r\n\r\nexport default PrefixSumKernel", "const radixSortSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = select(input[GID], 0, GID >= ELEMENT_COUNT);\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        var prefix_sum: u32 = 0;\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                prefix_sum = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            s_prefix_sum[outOffset] = prefix_sum;\r\n            \r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Store local prefix sum to global memory\r\n        local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\r\n    }\r\n}`\r\n\r\nexport default radixSortSource;", "/**\r\n * Radix sort with \"local shuffle and coalesced mapping\" optimization\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst radixSortCoalescedSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    var elm: u32 = 0;\r\n    var val: u32 = 0;\r\n    if (GID < ELEMENT_COUNT) {\r\n        elm = input[GID];\r\n        val = values[GID];\r\n    }\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        var prefix_sum: u32 = 0;\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                prefix_sum = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            s_prefix_sum[outOffset] = prefix_sum;\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    let prefix_sum = bit_prefix_sums[extract_bits];   \r\n\r\n    // Scan bit prefix sums\r\n    if (TID == LAST_THREAD) {\r\n        var sum: u32 = 0;\r\n        bit_prefix_sums[extract_bits] += 1;\r\n        for (var i: u32 = 0; i < 4; i++) {\r\n            s_prefix_sum_scan[i] = sum;\r\n            sum += bit_prefix_sums[i];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Compute new position\r\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\r\n\r\n        // Shuffle elements locally\r\n        input[WID + new_pos] = elm;\r\n        values[WID + new_pos] = val;\r\n        local_prefix_sums[WID + new_pos] = prefix_sum;\r\n    }\r\n}`\r\n\r\nexport default radixSortCoalescedSource;", "const radixSortReorderSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\r\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\r\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\r\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort_reorder(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) { \r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    if (GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let k = inputKeys[GID];\r\n    let v = inputValues[GID];\r\n\r\n    let local_prefix = local_prefix_sum[GID];\r\n\r\n    // Calculate new position\r\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\r\n    let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\r\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\r\n    \r\n    outputKeys[sorted_position] = k;\r\n    outputValues[sorted_position] = v;\r\n}`\r\n\r\nexport default radixSortReorderSource;", "const checkSortSource = (isFirstPass = false, isLastPass = false, kernelMode = 'full') => /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<storage, read> original: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\noverride START_ELEMENT: u32;\r\n\r\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\r\n\r\n// Reset dispatch buffer and is_sorted flag\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reset(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    if (TID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    if (TID == 0) {\r\n        is_sorted = 0u;\r\n    }\r\n\r\n    let ELM_ID = TID * 3;\r\n\r\n    output[ELM_ID] = original[ELM_ID];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn check_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\r\n    let GID = TID + WID; // Global thread ID\r\n\r\n    // Load data into shared memory\r\n    ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);\" }\r\n\r\n    // Perform parallel reduction\r\n    for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {      \r\n        workgroupBarrier();  \r\n        if (TID % (2u * d) == 0u) {\r\n            s_data[TID] += s_data[TID + d];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Write reduction result\r\n    ${ isLastPass ? last_pass(kernelMode) : write_reduction_result }\r\n}`\r\n\r\nconst write_reduction_result = /* wgsl */ `\r\n    if (TID == 0) {\r\n        output[WORKGROUP_ID] = s_data[0];\r\n    }\r\n`\r\n\r\nconst first_pass_load_data = /* wgsl */ `\r\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n\r\n    // Load current element into shared memory\r\n    // Also load next element for comparison\r\n    let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\r\n    let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\r\n    s_data[TID] = elm;\r\n    workgroupBarrier();\r\n\r\n    s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\r\n`\r\n\r\nconst last_pass = (kernelMode) => /* wgsl */ `\r\n    let fullDispatchLength = arrayLength(&output);\r\n    let dispatchIndex = TID * 3;\r\n\r\n    if (dispatchIndex >= fullDispatchLength) {\r\n        return;\r\n    }\r\n\r\n    ${kernelMode == 'full' ? last_pass_full : last_pass_fast}\r\n`\r\n\r\n// If the fast check kernel is sorted and the data isn't already sorted, run the full check\r\nconst last_pass_fast = /* wgsl */ `\r\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\r\n`\r\n\r\n// If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\r\nconst last_pass_full = /* wgsl */ `\r\n    if (TID == 0 && s_data[0] == 0) {\r\n        is_sorted = 1u;\r\n    }\r\n\r\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\r\n`\r\nexport default checkSortSource", "import checkSortSource from \"./shaders/check_sort\"\r\nimport { find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass CheckSortKernel {\r\n    /**\r\n     * CheckSortKernel - Performs a parralel reduction to check if an array is sorted.\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - The buffer containing the data to check\r\n     * @param {GPUBuffer} result - The result dispatch size buffer\r\n     * @param {GPUBuffer} original - The original dispatch size buffer\r\n     * @param {GPUBuffer} is_sorted - 1-element buffer to store whether the array is sorted\r\n     * @param {number} count - The number of elements to check\r\n     * @param {number} start - The index to start checking from\r\n     * @param {boolean} mode - The type of check sort kernel ('reset', 'fast', 'full')\r\n     * @param {object} workgroup_size - The workgroup size in x and y dimensions\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        result,\r\n        original,\r\n        is_sorted,\r\n        count,\r\n        start = 0,\r\n        mode = 'full',\r\n        workgroup_size = { x: 16, y: 16 },\r\n    }) {\r\n        this.device = device\r\n        this.count = count\r\n        this.start = start\r\n        this.mode = mode\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n\r\n        this.pipelines = []\r\n\r\n        this.buffers = {\r\n            data, \r\n            result, \r\n            original, \r\n            is_sorted,\r\n            outputs: []\r\n        }\r\n\r\n        this.create_passes_recursive(data, count)\r\n    }\r\n\r\n    // Find the best dispatch size for each pass to minimize unused workgroups\r\n    static find_optimal_dispatch_chain(device, item_count, workgroup_size) {\r\n        const threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        const sizes = []\r\n\r\n        do {\r\n            // Number of workgroups required to process all items\r\n            const target_workgroup_count = Math.ceil(item_count / threads_per_workgroup)\r\n    \r\n            // Optimal dispatch size and updated workgroup count\r\n            const dispatchSize = find_optimal_dispatch_size(device, target_workgroup_count)\r\n    \r\n            sizes.push(dispatchSize.x, dispatchSize.y, 1)\r\n            item_count = target_workgroup_count\r\n        } while (item_count > 1)\r\n    \r\n        return sizes\r\n    }\r\n\r\n    create_passes_recursive(buffer, count, passIndex = 0) {\r\n        const workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n\r\n        const isFirstPass = passIndex === 0\r\n        const isLastPass = workgroup_count <= 1\r\n\r\n        const label = `check-sort-${this.mode}-${passIndex}`\r\n\r\n        const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\r\n            label: label,\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                // Last pass bindings\r\n                ...(isLastPass ? [{\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                }, {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : []),\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: buffer }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outputBuffer }\r\n                },\r\n                // Last pass buffers\r\n                ...(isLastPass ? [{\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.original }\r\n                }, {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.is_sorted }\r\n                }] : []),\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [bindGroupLayout]\r\n        })\r\n\r\n        const element_count = isFirstPass ? this.start + count : count\r\n        const start_element = isFirstPass ? this.start : 0\r\n\r\n        const checkSortPipeline = this.device.createComputePipeline({\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.device.createShaderModule({\r\n                    label: label,\r\n                    code: checkSortSource(isFirstPass, isLastPass, this.mode),\r\n                }),\r\n                entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\r\n                constants: {\r\n                    'ELEMENT_COUNT': element_count,\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    ...(this.mode != 'reset' && { \r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                        'START_ELEMENT': start_element,\r\n                    })\r\n                },\r\n            }\r\n        })\r\n\r\n        this.buffers.outputs.push(outputBuffer)\r\n        this.pipelines.push({ pipeline: checkSortPipeline, bindGroup })\r\n        \r\n        if (!isLastPass) {\r\n            this.create_passes_recursive(outputBuffer, workgroup_count, passIndex + 1)\r\n        }\r\n    }\r\n\r\n    dispatch(pass, dispatchSize, offset = 0) {\r\n        for (let i = 0; i < this.pipelines.length; i++) {\r\n            const { pipeline, bindGroup } = this.pipelines[i]\r\n\r\n            const dispatchIndirect = this.mode != 'reset' && (this.mode == 'full' || i < this.pipelines.length - 1)\r\n\r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n\r\n            if (dispatchIndirect)\r\n                pass.dispatchWorkgroupsIndirect(dispatchSize, offset + i * 3 * 4)\r\n            else\r\n                // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\r\n                pass.dispatchWorkgroups(1, 1, 1)\r\n        }\r\n    }\r\n}\r\n\r\nexport default CheckSortKernel", "import PrefixSumKernel from \"./PrefixSumKernel\"\r\nimport radixSortSource from \"./shaders/radix_sort\"\r\nimport radixSortSource_LocalShuffle from \"./shaders/optimizations/radix_sort_local_shuffle\"\r\nimport reorderSource from \"./shaders/radix_sort_reorder\"\r\nimport CheckSortKernel from \"./CheckSortKernel\"\r\nimport { create_buffer_from_data, find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass RadixSortKernel {\r\n    /**\r\n     * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\r\n     * Note: The buffers are sorted in-place.\r\n     * \r\n     * Based on \"Fast 4-way parallel radix sorting on GPUs\"\r\n     * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} keys - Buffer containing the keys to sort\r\n     * @param {GPUBuffer} values - (optional) Buffer containing the associated values\r\n     * @param {number} count - Number of elements to sort\r\n     * @param {number} bit_count - Number of bits per element (default: 32)\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} check_order - Enable \"order checking\" optimization. Can improve performance if the data needs to be sorted in real-time and doesn't change much. (default: false)\r\n     * @param {boolean} local_shuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\r\n     * @param {boolean} avoid_bank_conflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\r\n     */\r\n    constructor({\r\n        device,\r\n        keys,\r\n        values,\r\n        count,\r\n        bit_count = 32,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        check_order = false,\r\n        local_shuffle = false,\r\n        avoid_bank_conflicts = false,\r\n    } = {}) {\r\n        if (device == null) throw new Error('No device provided')\r\n        if (keys == null) throw new Error('No keys buffer provided')\r\n        if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter')\r\n        if (!Number.isInteger(bit_count) || bit_count <= 0 || bit_count > 32) throw new Error(`Invalid bit_count parameter: ${bit_count}`)\r\n        if (!Number.isInteger(workgroup_size.x) || !Number.isInteger(workgroup_size.y)) throw new Error('Invalid workgroup_size parameter')\r\n        if (bit_count % 4 != 0) throw new Error('bit_count must be a multiple of 4')\r\n\r\n        this.device = device\r\n        this.count = count\r\n        this.bit_count = bit_count\r\n        this.workgroup_size = workgroup_size\r\n        this.check_order = check_order\r\n        this.local_shuffle = local_shuffle\r\n        this.avoid_bank_conflicts = avoid_bank_conflicts\r\n\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n        this.prefix_block_workgroup_count = 4 * this.workgroup_count\r\n\r\n        this.has_values = (values != null) // Is the values buffer provided ?\r\n\r\n        this.dispatchSize = {}  // Dispatch dimension x and y\r\n        this.shaderModules = {} // GPUShaderModules\r\n        this.kernels = {}       // PrefixSumKernel & CheckSortKernels\r\n        this.pipelines = []     // List of passes\r\n        this.buffers = {        // GPUBuffers\r\n            keys: keys,\r\n            values: values\r\n        }       \r\n\r\n        // Create shader modules from wgsl code\r\n        this.create_shader_modules()\r\n        \r\n        // Create multi-pass pipelines\r\n        this.create_pipelines()\r\n    }\r\n\r\n    create_shader_modules() {\r\n        // Remove every occurence of \"values\" in the shader code if values buffer is not provided\r\n        const remove_values = (source) => {\r\n            return source.split('\\n')\r\n                         .filter(line => !line.toLowerCase().includes('values'))\r\n                         .join('\\n')\r\n        }\r\n\r\n        const blockSumSource = this.local_shuffle ? radixSortSource_LocalShuffle : radixSortSource\r\n        \r\n        this.shaderModules = {\r\n            blockSum: this.device.createShaderModule({\r\n                label: 'radix-sort-block-sum',\r\n                code: this.has_values ? blockSumSource : remove_values(blockSumSource),\r\n            }),\r\n            reorder: this.device.createShaderModule({\r\n                label: 'radix-sort-reorder',\r\n                code: this.has_values ? reorderSource : remove_values(reorderSource),\r\n            })\r\n        }\r\n    }\r\n\r\n    create_pipelines() {    \r\n        // Block prefix sum kernel    \r\n        this.create_prefix_sum_kernel()\r\n\r\n        // Indirect dispatch buffers\r\n        const dispatchData = this.calculate_dispatch_sizes()\r\n\r\n        // GPU buffers\r\n        this.create_buffers(dispatchData)\r\n\r\n        // Check sort kernels\r\n        this.create_check_sort_kernels(dispatchData)\r\n\r\n        // Radix sort passes for every 2 bits\r\n        for (let bit = 0; bit < this.bit_count; bit += 2) {\r\n            // Swap buffers every pass\r\n            const even      = (bit % 4 == 0)\r\n            const inKeys    = even ? this.buffers.keys : this.buffers.tmpKeys\r\n            const inValues  = even ? this.buffers.values : this.buffers.tmpValues\r\n            const outKeys   = even ? this.buffers.tmpKeys : this.buffers.keys\r\n            const outValues = even ? this.buffers.tmpValues : this.buffers.values\r\n\r\n            // Compute local prefix sums and block sums\r\n            const blockSumPipeline = this.create_block_sum_pipeline(inKeys, inValues, bit)\r\n            \r\n            // Reorder keys and values\r\n            const reorderPipeline = this.create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit)\r\n\r\n            this.pipelines.push({ blockSumPipeline, reorderPipeline })\r\n        }\r\n    }\r\n\r\n    create_prefix_sum_kernel() {\r\n        // Prefix Block Sum buffer (4 element per workgroup)\r\n        const prefixBlockSumBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-prefix-block-sum',\r\n            size: this.prefix_block_workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create block prefix sum kernel\r\n        const prefixSumKernel = new PrefixSumKernel({ \r\n            device: this.device,\r\n            data: prefixBlockSumBuffer, \r\n            count: this.prefix_block_workgroup_count,\r\n            workgroup_size: this.workgroup_size,\r\n            avoid_bank_conflicts: this.avoid_bank_conflicts,\r\n        })\r\n\r\n        this.kernels.prefixSum = prefixSumKernel\r\n        this.buffers.prefixBlockSum = prefixBlockSumBuffer\r\n    }\r\n\r\n    calculate_dispatch_sizes() {\r\n        // Radix sort dispatch size\r\n        const dispatchSize = find_optimal_dispatch_size(this.device, this.workgroup_count)\r\n\r\n        // Prefix sum dispatch sizes\r\n        const prefixSumDispatchSize = this.kernels.prefixSum.get_dispatch_chain()\r\n\r\n        // Check sort element count (fast/full)\r\n        const check_sort_fast_count = Math.min(this.count, this.threads_per_workgroup * 4)\r\n        const check_sort_full_count = this.count - check_sort_fast_count\r\n        const start_full = check_sort_fast_count - 1\r\n\r\n        // Check sort dispatch sizes\r\n        const dispatchSizesFast = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_fast_count, this.workgroup_size)\r\n        const dispatchSizesFull = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_full_count, this.workgroup_size)\r\n\r\n        // Initial dispatch sizes\r\n        const initialDispatch = [\r\n            dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\r\n            ...dispatchSizesFast.slice(0, 3),  // Check sort fast\r\n            ...prefixSumDispatchSize           // Prefix Sum\r\n        ]\r\n\r\n        // Dispatch offsets in main buffer\r\n        this.dispatchOffsets = {\r\n            radix_sort: 0,\r\n            check_sort_fast: 3 * 4,\r\n            prefix_sum: 6 * 4\r\n        }\r\n\r\n        this.dispatchSize = dispatchSize\r\n        this.initialDispatch = initialDispatch\r\n\r\n        return {\r\n            initialDispatch,\r\n            dispatchSizesFull,\r\n            check_sort_fast_count, \r\n            check_sort_full_count, \r\n            start_full \r\n        }\r\n    }\r\n\r\n    create_buffers(dispatchData) {\r\n        // Keys and values double buffering\r\n        const tmpKeysBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-tmp-keys',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        const tmpValuesBuffer = !this.has_values ? null : this.device.createBuffer({\r\n            label: 'radix-sort-tmp-values',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Local Prefix Sum buffer (1 element per item)\r\n        const localPrefixSumBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-local-prefix-sum',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        this.buffers.tmpKeys = tmpKeysBuffer\r\n        this.buffers.tmpValues = tmpValuesBuffer\r\n        this.buffers.localPrefixSum = localPrefixSumBuffer\r\n\r\n        // Only create indirect dispatch buffers when check_order optimization is enabled\r\n        if (!this.check_order) {\r\n            return\r\n        }\r\n\r\n        // Dispatch sizes (radix sort, check sort, prefix sum)\r\n        const dispatchBuffer = create_buffer_from_data({\r\n            device: this.device, \r\n            label: 'radix-sort-dispatch-size',\r\n            data: dispatchData.initialDispatch, \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\r\n        })\r\n        const originalDispatchBuffer = create_buffer_from_data({\r\n            device: this.device, \r\n            label: 'radix-sort-dispatch-size-original',\r\n            data: dispatchData.initialDispatch, \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        })\r\n\r\n        // Dispatch sizes (full sort)\r\n        const checkSortFullDispatchBuffer = create_buffer_from_data({\r\n            label: 'check-sort-full-dispatch-size',\r\n            device: this.device, \r\n            data: dispatchData.dispatchSizesFull,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\r\n        })\r\n        const checkSortFullOriginalDispatchBuffer = create_buffer_from_data({\r\n            label: 'check-sort-full-dispatch-size-original',\r\n            device: this.device, \r\n            data: dispatchData.dispatchSizesFull,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        })\r\n\r\n        // Flag to tell if the data is sorted\r\n        const isSortedBuffer = create_buffer_from_data({\r\n            label: 'is-sorted',\r\n            device: this.device, \r\n            data: new Uint32Array([0]), \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        this.buffers.dispatchSize = dispatchBuffer\r\n        this.buffers.originalDispatchSize = originalDispatchBuffer\r\n        this.buffers.checkSortFullDispatchSize = checkSortFullDispatchBuffer\r\n        this.buffers.originalCheckSortFullDispatchSize = checkSortFullOriginalDispatchBuffer\r\n        this.buffers.isSorted = isSortedBuffer\r\n    }\r\n\r\n    create_check_sort_kernels(checkSortPartitionData) {\r\n        if (!this.check_order) {\r\n            return\r\n        }\r\n\r\n        const { check_sort_fast_count, check_sort_full_count, start_full } = checkSortPartitionData\r\n\r\n        // Create the full pass\r\n        const checkSortFull = new CheckSortKernel({\r\n            mode: 'full',\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            result: this.buffers.dispatchSize,\r\n            original: this.buffers.originalDispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: check_sort_full_count,\r\n            start: start_full,\r\n            workgroup_size: this.workgroup_size\r\n        })\r\n\r\n        // Create the fast pass\r\n        const checkSortFast = new CheckSortKernel({\r\n            mode: 'fast',\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            result: this.buffers.checkSortFullDispatchSize,\r\n            original: this.buffers.originalCheckSortFullDispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: check_sort_fast_count,\r\n            workgroup_size: this.workgroup_size\r\n        })\r\n\r\n        const initialDispatchElementCount = this.initialDispatch.length / 3\r\n\r\n        if (checkSortFast.threads_per_workgroup < checkSortFull.pipelines.length || checkSortFull.threads_per_workgroup < initialDispatchElementCount) {\r\n            console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`)\r\n            this.check_order = false\r\n            return\r\n        }\r\n\r\n        // Create the reset pass\r\n        const checkSortReset = new CheckSortKernel({\r\n            mode: 'reset',\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            original: this.buffers.originalDispatchSize,\r\n            result: this.buffers.dispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: initialDispatchElementCount,\r\n            workgroup_size: find_optimal_dispatch_size(this.device, initialDispatchElementCount)\r\n        })\r\n\r\n        this.kernels.checkSort = {\r\n            reset: checkSortReset,\r\n            fast: checkSortFast,\r\n            full: checkSortFull,\r\n        }\r\n    }\r\n\r\n    create_block_sum_pipeline(inKeys, inValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-block-sum',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: this.local_shuffle ? 'storage' : 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                // \"Local shuffle\" optimization needs access to the values buffer\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    resource: { buffer: inValues }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const blockSumPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-block-sum',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.blockSum,\r\n                entryPoint: 'radix_sort',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: blockSumPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-reorder',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'read-only-storage' }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'storage' }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outKeys }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        resource: { buffer: inValues }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        resource: { buffer: outValues }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const reorderPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-reorder',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.reorder,\r\n                entryPoint: 'radix_sort_reorder',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: reorderPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode all pipelines into the current pass\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     */\r\n    dispatch(pass) {\r\n        if (!this.check_order) {\r\n            this.#dispatchPipelines(pass)\r\n        }\r\n        else {\r\n            this.#dispatchPipelinesIndirect(pass)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch workgroups from CPU args\r\n     */\r\n    #dispatchPipelines(pass) {\r\n        for (let i = 0; i < this.bit_count / 2; i++) {\r\n            const { blockSumPipeline, reorderPipeline } = this.pipelines[i]\r\n            \r\n            // Compute local prefix sums and block sums\r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n\r\n            // Compute block sums prefix sum\r\n            this.kernels.prefixSum.dispatch(pass)\r\n\r\n            // Reorder keys and values\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch workgroups from indirect GPU buffers (used when check_order is enabled)\r\n     */\r\n    #dispatchPipelinesIndirect(pass) {\r\n        // Reset the `dispatch` and `is_sorted` buffers\r\n        this.kernels.checkSort.reset.dispatch(pass)\r\n        \r\n        for (let i = 0; i < this.bit_count / 2; i++) {\r\n            const { blockSumPipeline, reorderPipeline } = this.pipelines[i]\r\n\r\n            if (i % 2 == 0) {\r\n                // Check if the data is sorted every 2 passes\r\n                this.kernels.checkSort.fast.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.check_sort_fast)\r\n                this.kernels.checkSort.full.dispatch(pass, this.buffers.checkSortFullDispatchSize)\r\n            }\r\n            \r\n            // Compute local prefix sums and block sums\r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort)\r\n\r\n            // Compute block sums prefix sum\r\n            this.kernels.prefixSum.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefix_sum)\r\n\r\n            // Reorder keys and values\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort)\r\n        }\r\n    }\r\n}\r\n\r\nexport default RadixSortKernel", "export const renderShaders = /* wgsl */`\r\nstruct Uniforms {\r\n  viewProjectionMatrix : mat4x4<f32>,\r\n  invVPMatrix : mat4x4<f32>,\r\n  backgroundColour: vec4<f32>,\r\n  camPos: vec3<f32>,\r\n  aspectRatio : f32,\r\n}\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\nstruct VertexOut {\r\n  @builtin(position) position : vec4f,\r\n  @location(0) colour : vec4f,\r\n  @location(1) uv : vec2f,\r\n  @location(2) worldPos: vec3f,\r\n  @location(3) normal: vec3f,\r\n  @location(4) fadeFac: f32,\r\n}\r\n\r\nstruct VertexInput {\r\n  @location(0) position : vec3f,\r\n  @location(1) uv : vec2f\r\n}\r\n\r\nstruct InstanceInput {\r\n  @location(2) position : vec4f,\r\n  @location(3) velocity : vec4f,\r\n  @location(4) normal : vec4f,\r\n  @location(5) dist : f32,\r\n  @location(6) density : f32,\r\n  @location(7) cellIndex: u32,\r\n  @location(8) group: f32\r\n}\r\n\r\n\r\n@vertex\r\nfn vertex_main(\r\n  vertex: VertexInput,\r\n  instance: InstanceInput\r\n) -> VertexOut {\r\n  var output : VertexOut;\r\n  var position = instance.position;\r\n\r\n  // // WARP PARTICLE POSITION\r\n  // const R = 100.0;\r\n  // let theta = position.x / R;\r\n  \r\n  // // base arc point (radius R)\r\n  // let bx = R * sin(theta);\r\n  // let bz = R * (1.0 - cos(theta));\r\n\r\n  // // apply radial offset\r\n  // position.x = bx + position.z * sin(theta);\r\n  // position.z = bz + position.z * -cos(theta);\r\n\r\n\r\n  output.position = uniforms.viewProjectionMatrix * position;\r\n\r\n  // SCREEN SPACE SIZE PARTICLES (zoom invariant)\r\n  // const particleSize = 0.003;\r\n  // let vertPos = vertex.position.xy * vec2f(particleSize / uniforms.aspectRatio, particleSize) * output.position.w;\r\n\r\n  // WORLD SPACE SIZE PARTICLES\r\n  const particleSize = 1.0;\r\n  let vertPos = vertex.position.xy * vec2f(particleSize / uniforms.aspectRatio, particleSize);\r\n  \r\n\r\n  output.position += vec4f(vertPos, 0., 0.);\r\n  output.worldPos = (uniforms.invVPMatrix * output.position).xyz;\r\n\r\n  const baseColor1 = vec4f(0.3, 0.7, 0.8, 1.0);\r\n  const baseColor2 = vec4f(0.0, 0.3, 0.8, 1.0);\r\n  output.colour = mix(baseColor1, baseColor2, 0.5*instance.group + 0.5);\r\n\r\n  // // SHADE COLLISIONS\r\n  // const densityRange = 0.1; // density scalar will vary for density values in range [1, 1+densityRange]\r\n  // let densityScalar = saturate((instance.density - 1.1)/densityRange); // 0 for no collisions, 1 for big collision\r\n  // var colour = (1.0-densityScalar) * baseColor1 + densityScalar * baseColor2;\r\n\r\n\r\n  // FADE PARTICLES IN AT THE START\r\n  const startFadeY = 40;\r\n  const endFadeY = 20;\r\n  output.fadeFac = saturate((abs(instance.position.y)-startFadeY)/(endFadeY-startFadeY));\r\n\r\n\r\n  output.uv = vertex.uv;\r\n  output.normal = instance.normal.xyz; // could use improvement so normal is not constant across all fragments\r\n\r\n  return output;\r\n}\r\n\r\n@fragment\r\nfn fragment_main(fragData: VertexOut) -> @location(0) vec4f {\r\n  let uvLength = length(fragData.uv - vec2f(0.5, 0.5)) * 2.0;\r\n  if (uvLength > 1.0) {\r\n    discard;\r\n  } \r\n  // smooth circle edge (need to switch on alpha blending)\r\n  // const falloff = 5.0;\r\n  // let alpha = clamp(falloff * (1.0 - uvLength), 0.0, 1.0);\r\n  // return vec4f(fragData.colour.rgb * alpha, fragData.colour.a * alpha);\r\n\r\n\r\n  const lightDir = normalize(vec3<f32>(0.1, 0.8, 1.0));\r\n\r\n  // DIFFUSE SHADING\r\n  const diffuseStrength = 0.5;\r\n  let diffuseIntensity = diffuseStrength * dot(lightDir, fragData.normal) + 0.9 - diffuseStrength; \r\n\r\n  // SPECULAR SHADING\r\n  let viewDir = normalize(uniforms.camPos - fragData.worldPos);\r\n  \r\n  const specularColour = vec4<f32>(1.0);\r\n  const specularExponent = 50.0;\r\n  let halfDir = normalize(normalize(lightDir) + viewDir);\r\n  let specularIntensity = 0.3*pow(max(dot(fragData.normal, halfDir), 0.0), specularExponent);\r\n\r\n\r\n\r\n\r\n  \r\n  var colour = saturate(diffuseIntensity*fragData.colour + specularIntensity*specularColour);\r\n\r\n\r\n  \r\n  colour = mix(uniforms.backgroundColour, colour, fragData.fadeFac);\r\n\r\n  return colour;\r\n}\r\n\r\n`;\r\n", "export const createSquareData = () => {\r\n  const positions = [\r\n    -0.5, -0.5,  0,\r\n     0.5, -0.5,  0,\r\n    -0.5,  0.5,  0,\r\n\r\n     0.5, -0.5,  0,\r\n    -0.5,  0.5,  0,\r\n     0.5,  0.5,  0\r\n    ];\r\n\r\n  const uvs = [\r\n    0, 0,\r\n    1, 0,\r\n    0, 1,\r\n\r\n    1, 0,\r\n    0, 1,\r\n    1, 1\r\n  ];\r\n  \r\n  const data = new Float32Array(positions.length + uvs.length);\r\n  for (let i = 0; i < 6; i++) {\r\n    data[5*i + 0] = positions[3*i + 0];\r\n    data[5*i + 1] = positions[3*i + 1];\r\n    data[5*i + 2] = positions[3*i + 2];\r\n\r\n    data[5*i + 3] = uvs[2*i + 0];\r\n    data[5*i + 4] = uvs[2*i + 1];\r\n  }\r\n  return data;\r\n}", "/**\n * A type wider than `number[]`, omitting any instance functions\n * unused by the API, e.g., map, sort. This allows the math\n * functions to operate on a wider range of array-like\n * values.\n */\nexport interface MutableNumberArray {\n  readonly length: number;\n  [n: number]: number;\n}\n\n/**\n * The types you can pass to most functions that take an\n * array of numbers.\n */\nexport type BaseArgType = Float32Array | Float64Array | MutableNumberArray;\n\nfunction wrapConstructor<T extends new(...args: any[]) => any>(\n  OriginalConstructor: T,\n  modifier: (instance: InstanceType<T>) => void\n): T {\n  return class extends OriginalConstructor {\n    constructor(...args: any[]) {\n      super(...args);\n      modifier(this as InstanceType<T>);\n    }\n  } as T; // Type assertion is necessary here\n}\n\nexport const ZeroArray = wrapConstructor(Array<number>, a => a.fill(0));\n\n", "/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nexport let EPSILON = 0.000001;\n\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nexport function setEpsilon(v: number): number {\n  const old = EPSILON;\n  EPSILON = v;\n  return old;\n}\n\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nexport function degToRad(degrees: number): number {\n  return degrees * Math.PI / 180;\n}\n\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nexport function radToDeg(radians: number): number {\n  return radians * 180 / Math.PI;\n}\n\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nexport function inverseLerp(a: number, b: number, v: number): number {\n  const d = b - a;\n  return (Math.abs(b - a) < EPSILON)\n     ? a\n     : (v - a) / d;\n}\n\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nexport function euclideanModulo(n: number, m: number) {\n  return ((n % m) + m) % m;\n}", "/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport * as utils from './utils.js';\nimport { Mat3Arg } from './mat3';\nimport { Mat4Arg } from './mat4';\nimport { Vec2Arg, Vec2Type } from './vec2';\nimport { Vec3Arg } from './vec3';\nimport { BaseArgType } from './types';\n\nexport { Vec2Arg, Vec2Type };\n\ntype Vec2Ctor<T extends Vec2Arg = Float32Array>  = new (n: number) => T;\n\n/**\n * Generates am typed API for Vec3\n */\nfunction getAPIImpl<VecType extends Vec2Arg = Float32Array>(Ctor: Vec2Ctor<VecType>) {\n\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create(x = 0, y = 0) {\n  const newDst = new Ctor(2);\n  if (x !== undefined) {\n    newDst[0] = x;\n    if (y !== undefined) {\n      newDst[1] = y;\n    }\n  }\n  return newDst;\n}\n\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues = create;\n\n/**\n * Sets the values of a Vec2\n * Also see {@link vec2.create} and {@link vec2.copy}\n *\n * @param x first value\n * @param y second value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set<T extends Vec2Arg = VecType>(x: number, y: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = x;\n  newDst[1] = y;\n\n  return newDst;\n}\n\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = Math.ceil(v[0]);\n  newDst[1] = Math.ceil(v[1]);\n\n  return newDst;\n}\n\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = Math.floor(v[0]);\n  newDst[1] = Math.floor(v[1]);\n\n  return newDst;\n}\n\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = Math.round(v[0]);\n  newDst[1] = Math.round(v[1]);\n\n  return newDst;\n}\n\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp<T extends Vec2Arg = VecType>(v: Vec2Arg, min = 0, max = 1, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = Math.min(max, Math.max(min, v[0]));\n  newDst[1] = Math.min(max, Math.max(min, v[1]));\n\n  return newDst;\n}\n\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] + b[0];\n  newDst[1] = a[1] + b[1];\n\n  return newDst;\n}\n\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, scale: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] + b[0] * scale;\n  newDst[1] = a[1] + b[1] * scale;\n\n  return newDst;\n}\n\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle(a: Vec2Arg, b: Vec2Arg): number {\n  const ax = a[0];\n  const ay = a[1];\n  const bx = b[0];\n  const by = b[1];\n  const mag1 = Math.sqrt(ax * ax + ay * ay);\n  const mag2 = Math.sqrt(bx * bx + by * by);\n  const mag = mag1 * mag2;\n  const cosine = mag && dot(a, b) / mag;\n  return Math.acos(cosine);\n}\n\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] - b[0];\n  newDst[1] = a[1] - b[1];\n\n  return newDst;\n}\n\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a: Vec2Arg, b: Vec2Arg): boolean {\n  return Math.abs(a[0] - b[0]) < utils.EPSILON &&\n         Math.abs(a[1] - b[1]) < utils.EPSILON;\n}\n\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a: Vec2Arg, b: Vec2Arg): boolean {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, t: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] + t * (b[0] - a[0]);\n  newDst[1] = a[1] + t * (b[1] - a[1]);\n\n  return newDst;\n}\n\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, t: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n  newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n\n  return newDst;\n}\n\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = Math.max(a[0], b[0]);\n  newDst[1] = Math.max(a[1], b[1]);\n\n  return newDst;\n}\n\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = Math.min(a[0], b[0]);\n  newDst[1] = Math.min(a[1], b[1]);\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar<T extends Vec2Arg = VecType>(v: Vec2Arg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = v[0] * k;\n  newDst[1] = v[1] * k;\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar<T extends Vec2Arg = VecType>(v: Vec2Arg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = v[0] / k;\n  newDst[1] = v[1] / k;\n\n  return newDst;\n}\n\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = 1 / v[0];\n  newDst[1] = 1 / v[1];\n\n  return newDst;\n}\n\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross<T extends Vec3Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n  const z = a[0] * b[1] - a[1] * b[0];\n  newDst[0] = 0;\n  newDst[1] = 0;\n  newDst[2] = z;\n\n  return newDst;\n}\n\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a: Vec2Arg, b: Vec2Arg): number {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v: Vec2Arg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  return Math.sqrt(v0 * v0 + v1 * v1);\n}\n\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v: Vec2Arg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  return v0 * v0 + v1 * v1;\n}\n\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a: Vec2Arg, b: Vec2Arg): number {\n  const dx = a[0] - b[0];\n  const dy = a[1] - b[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a: Vec2Arg, b: Vec2Arg): number {\n  const dx = a[0] - b[0];\n  const dy = a[1] - b[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const len = Math.sqrt(v0 * v0 + v1 * v1);\n\n  if (len > 0.00001) {\n    newDst[0] = v0 / len;\n    newDst[1] = v1 / len;\n  } else {\n    newDst[0] = 0;\n    newDst[1] = 0;\n  }\n\n  return newDst;\n}\n\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = -v[0];\n  newDst[1] = -v[1];\n\n  return newDst;\n}\n\n/**\n * Copies a vector. (same as {@link vec2.clone})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy<T extends Vec2Arg = VecType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = v[0];\n  newDst[1] = v[1];\n\n  return newDst;\n}\n\n/**\n * Clones a vector. (same as {@link vec2.copy})\n * Also see {@link vec2.create} and {@link vec2.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] * b[0];\n  newDst[1] = a[1] * b[1];\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = a[0] / b[0];\n  newDst[1] = a[1] / b[1];\n\n  return newDst;\n}\n\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random<T extends Vec2Arg = VecType>(scale = 1, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  const angle = Math.random() * 2 * Math.PI;\n  newDst[0] = Math.cos(angle) * scale;\n  newDst[1] = Math.sin(angle) * scale;\n\n  return newDst;\n}\n\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero<T extends Vec2Arg = VecType>(dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  newDst[0] = 0;\n  newDst[1] = 0;\n\n  return newDst;\n}\n\n\n/**\n * Transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4<T extends Vec2Arg = VecType>(v: Vec2Arg, m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  const x = v[0];\n  const y = v[1];\n\n  newDst[0] = x * m[0] + y * m[4] + m[12];\n  newDst[1] = x * m[1] + y * m[5] + m[13];\n\n  return newDst;\n}\n\n/**\n * Transform Vec2 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3<T extends Vec2Arg = VecType>(v: Vec2Arg, m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  const x = v[0];\n  const y = v[1];\n\n  newDst[0] = m[0] * x + m[4] * y + m[8];\n  newDst[1] = m[1] * x + m[5] * y + m[9];\n\n  return newDst;\n}\n\n/**\n * Rotate a 2D vector\n *\n * @param a The vec2 point to rotate\n * @param b The origin of the rotation\n * @param rad The angle of rotation in radians\n * @returns the rotated vector\n */\nfunction rotate<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, rad: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  // Translate point to the origin\n  const p0 = a[0] - b[0];\n  const p1 = a[1] - b[1];\n  const sinC = Math.sin(rad);\n  const cosC = Math.cos(rad);\n\n  //perform rotation and translate to correct position\n  newDst[0] = p0 * cosC - p1 * sinC + b[0];\n  newDst[1] = p0 * sinC + p1 * cosC + b[1];\n\n  return newDst;\n}\n\n/**\n * Treat a 2D vector as a direction and set it's length\n *\n * @param a The vec2 to lengthen\n * @param len The length of the resulting vector\n * @returns The lengthened vector\n */\nfunction setLength<T extends Vec2Arg = VecType>(a: Vec2Arg, len: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n  normalize(a, newDst);\n  return mulScalar(newDst, len, newDst);\n}\n\n/**\n * Ensure a vector is not longer than a max length\n *\n * @param a The vec2 to limit\n * @param maxLen The longest length of the resulting vector\n * @returns The vector, shortened to maxLen if it's too long\n */\nfunction truncate<T extends Vec2Arg = VecType>(a: Vec2Arg, maxLen: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n\n  if (length(a) > maxLen) {\n    return setLength(a, maxLen, newDst);\n  }\n\n  return copy(a, newDst);\n}\n\n/**\n * Return the vector exactly between 2 endpoint vectors\n *\n * @param a Endpoint 1\n * @param b Endpoint 2\n * @returns The vector exactly residing between endpoints 1 and 2\n */\nfunction midpoint<T extends Vec2Arg = VecType>(a: Vec2Arg, b: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(2)) as T;\n  return lerp(a, b, 0.5, newDst);\n}\n\nreturn {\n  create,\n  fromValues,\n  set,\n  ceil,\n  floor,\n  round,\n  clamp,\n  add,\n  addScaled,\n  angle,\n  subtract,\n  sub,\n  equalsApproximately,\n  equals,\n  lerp,\n  lerpV,\n  max,\n  min,\n  mulScalar,\n  scale,\n  divScalar,\n  inverse,\n  invert,\n  cross,\n  dot,\n  length,\n  len,\n  lengthSq,\n  lenSq,\n  distance,\n  dist,\n  distanceSq,\n  distSq,\n  normalize,\n  negate,\n  copy,\n  clone,\n  multiply,\n  mul,\n  divide,\n  div,\n  random,\n  zero,\n  transformMat4,\n  transformMat3,\n  rotate,\n  setLength,\n  truncate,\n  midpoint,\n};\n}\n\ntype API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;\n\nconst cache = new Map();\n\nexport function getAPI<T extends Vec2Arg = Float32Array>(Ctor: Vec2Ctor<T>) {\n  let api = cache.get(Ctor);\n  if (!api) {\n    api = getAPIImpl<T>(Ctor);\n    cache.set(Ctor, api);\n  }\n  return api as API<T>;\n}\n", "/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport * as utils from './utils.js';\nimport { Vec3Arg, Vec3Type } from './vec3';\nimport { Mat3Arg } from './mat3';\nimport { Mat4Arg } from './mat4';\nimport { QuatArg } from './quat';\nimport { BaseArgType } from './types';\n\nexport { Vec3Arg, Vec3Type };\n\ntype Vec3Ctor<T extends Vec3Arg = Float32Array>  = new (n: number) => T;\n\n/**\n * Generates am typed API for Vec3\n * */\nfunction getAPIImpl<VecType extends Vec3Arg = Float32Array>(Ctor: Vec3Ctor<VecType>) {\n\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create(x?: number, y?: number, z?: number) {\n  const newDst = new Ctor(3);\n  if (x !== undefined) {\n    newDst[0] = x;\n    if (y !== undefined) {\n      newDst[1] = y;\n      if (z !== undefined) {\n        newDst[2] = z;\n      }\n    }\n  }\n  return newDst;\n}\n\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues = create;\n\n/**\n * Sets the values of a Vec3\n * Also see {@link vec3.create} and {@link vec3.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set<T extends Vec3Arg = VecType>(x: number, y: number, z: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = x;\n  newDst[1] = y;\n  newDst[2] = z;\n\n  return newDst;\n}\n\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = Math.ceil(v[0]);\n  newDst[1] = Math.ceil(v[1]);\n  newDst[2] = Math.ceil(v[2]);\n\n  return newDst;\n}\n\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = Math.floor(v[0]);\n  newDst[1] = Math.floor(v[1]);\n  newDst[2] = Math.floor(v[2]);\n\n  return newDst;\n}\n\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = Math.round(v[0]);\n  newDst[1] = Math.round(v[1]);\n  newDst[2] = Math.round(v[2]);\n\n  return newDst;\n}\n\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp<T extends Vec3Arg = VecType>(v: Vec3Arg, min = 0, max = 1, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = Math.min(max, Math.max(min, v[0]));\n  newDst[1] = Math.min(max, Math.max(min, v[1]));\n  newDst[2] = Math.min(max, Math.max(min, v[2]));\n\n  return newDst;\n}\n\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] + b[0];\n  newDst[1] = a[1] + b[1];\n  newDst[2] = a[2] + b[2];\n\n  return newDst;\n}\n\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, scale: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] + b[0] * scale;\n  newDst[1] = a[1] + b[1] * scale;\n  newDst[2] = a[2] + b[2] * scale;\n\n  return newDst;\n}\n\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle(a: Vec3Arg, b: Vec3Arg): number {\n  const ax = a[0];\n  const ay = a[1];\n  const az = a[2];\n  const bx = b[0];\n  const by = b[1];\n  const bz = b[2];\n  const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n  const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n  const mag = mag1 * mag2;\n  const cosine = mag && dot(a, b) / mag;\n  return Math.acos(cosine);\n}\n\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] - b[0];\n  newDst[1] = a[1] - b[1];\n  newDst[2] = a[2] - b[2];\n\n  return newDst;\n}\n\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a: Vec3Arg, b: Vec3Arg): boolean {\n  return Math.abs(a[0] - b[0]) < utils.EPSILON &&\n         Math.abs(a[1] - b[1]) < utils.EPSILON &&\n         Math.abs(a[2] - b[2]) < utils.EPSILON;\n}\n\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a: Vec3Arg, b: Vec3Arg): boolean {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, t: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] + t * (b[0] - a[0]);\n  newDst[1] = a[1] + t * (b[1] - a[1]);\n  newDst[2] = a[2] + t * (b[2] - a[2]);\n\n  return newDst;\n}\n\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, t: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n  newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n  newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n\n  return newDst;\n}\n\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = Math.max(a[0], b[0]);\n  newDst[1] = Math.max(a[1], b[1]);\n  newDst[2] = Math.max(a[2], b[2]);\n\n  return newDst;\n}\n\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = Math.min(a[0], b[0]);\n  newDst[1] = Math.min(a[1], b[1]);\n  newDst[2] = Math.min(a[2], b[2]);\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar<T extends Vec3Arg = VecType>(v: Vec3Arg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = v[0] * k;\n  newDst[1] = v[1] * k;\n  newDst[2] = v[2] * k;\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar<T extends Vec3Arg = VecType>(v: Vec3Arg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = v[0] / k;\n  newDst[1] = v[1] / k;\n  newDst[2] = v[2] / k;\n\n  return newDst;\n}\n\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = 1 / v[0];\n  newDst[1] = 1 / v[1];\n  newDst[2] = 1 / v[2];\n\n  return newDst;\n}\n\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const t1 = a[2] * b[0] - a[0] * b[2];\n  const t2 = a[0] * b[1] - a[1] * b[0];\n  newDst[0] = a[1] * b[2] - a[2] * b[1];\n  newDst[1] = t1;\n  newDst[2] = t2;\n\n  return newDst;\n}\n\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a: Vec3Arg, b: Vec3Arg): number {\n  return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v: Vec3Arg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v: Vec3Arg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  return v0 * v0 + v1 * v1 + v2 * v2;\n}\n\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a: Vec3Arg, b: Vec3Arg): number {\n  const dx = a[0] - b[0];\n  const dy = a[1] - b[1];\n  const dz = a[2] - b[2];\n  return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a: Vec3Arg, b: Vec3Arg): number {\n  const dx = a[0] - b[0];\n  const dy = a[1] - b[1];\n  const dz = a[2] - b[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n\n  if (len > 0.00001) {\n    newDst[0] = v0 / len;\n    newDst[1] = v1 / len;\n    newDst[2] = v2 / len;\n  } else {\n    newDst[0] = 0;\n    newDst[1] = 0;\n    newDst[2] = 0;\n  }\n\n\n  return newDst;\n}\n\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = -v[0];\n  newDst[1] = -v[1];\n  newDst[2] = -v[2];\n\n  return newDst;\n}\n\n/**\n * Copies a vector. (same as {@link vec3.clone})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy<T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = v[0];\n  newDst[1] = v[1];\n  newDst[2] = v[2];\n\n  return newDst;\n}\n\n/**\n * Clones a vector. (same as {@link vec3.copy})\n * Also see {@link vec3.create} and {@link vec3.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] * b[0];\n  newDst[1] = a[1] * b[1];\n  newDst[2] = a[2] * b[2];\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = a[0] / b[0];\n  newDst[1] = a[1] / b[1];\n  newDst[2] = a[2] / b[2];\n\n  return newDst;\n}\n\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random<T extends Vec3Arg = VecType>(scale = 1, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const angle = Math.random() * 2 * Math.PI;\n  const z = Math.random() * 2 - 1;\n  const zScale = Math.sqrt(1 - z * z) * scale;\n  newDst[0] = Math.cos(angle) * zScale;\n  newDst[1] = Math.sin(angle) * zScale;\n  newDst[2] = z * scale;\n\n  return newDst;\n}\n\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero<T extends Vec3Arg = VecType>(dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  newDst[0] = 0;\n  newDst[1] = 0;\n  newDst[2] = 0;\n\n  return newDst;\n}\n\n\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4<T extends Vec3Arg = VecType>(v: Vec3Arg, m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n  const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n\n  newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n\n  return newDst;\n}\n\n/**\n * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3<T extends Vec3Arg = VecType>(v: Vec3Arg, m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n\n  newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n  newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n  newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n\n  return newDst;\n}\n\n/**\n * Transforms vec3 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3<T extends Vec3Arg = VecType>(v: Vec3Arg, m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n\n  newDst[0] = x * m[0] + y * m[4] + z * m[8];\n  newDst[1] = x * m[1] + y * m[5] + z * m[9];\n  newDst[2] = x * m[2] + y * m[6] + z * m[10];\n\n  return newDst;\n}\n\n/**\n * Transforms vec3 by Quaternion\n * @param v - the vector to transform\n * @param q - the quaternion to transform by\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed\n */\nfunction transformQuat<T extends Vec3Arg = VecType>(v: Vec3Arg, q: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  const qx = q[0];\n  const qy = q[1];\n  const qz = q[2];\n  const w2 = q[3] * 2;\n\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n\n  const uvX = qy * z - qz * y;\n  const uvY = qz * x - qx * z;\n  const uvZ = qx * y - qy * x;\n\n  newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n  newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n  newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n\n  return newDst;\n}\n\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation<T extends Vec3Arg = VecType>(m: Mat3Arg, dst?: T) {\n    const newDst = (dst ?? new Ctor(3)) as T;\n    newDst[0] = m[12];\n    newDst[1] = m[13];\n    newDst[2] = m[14];\n    return newDst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis<T extends Vec3Arg = VecType>(m: Mat4Arg, axis: number, dst?: T) {\n    const newDst = (dst ?? new Ctor(3)) as T;\n    const off = axis * 4;\n    newDst[0] = m[off + 0];\n    newDst[1] = m[off + 1];\n    newDst[2] = m[off + 2];\n    return newDst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling<T extends Vec3Arg = VecType>(m: Mat4Arg, dst?: T) {\n    const newDst = (dst ?? new Ctor(3)) as T;\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return newDst;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n *\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @param dst - The vector to set. If not passed a new one is created.\n * @returns the rotated vector\n */\nfunction rotateX<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n  const p = [];\n  const r = [];\n\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n\n  //translate to correct position\n  newDst[0] = r[0] + b[0];\n  newDst[1] = r[1] + b[1];\n  newDst[2] = r[2] + b[2];\n\n  return newDst;\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n *\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @param dst - The vector to set. If not passed a new one is created.\n * @returns the rotated vector\n */\nfunction rotateY<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n  const p = [];\n  const r = [];\n\n  // translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  // perform rotation\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n  // translate to correct position\n  newDst[0] = r[0] + b[0];\n  newDst[1] = r[1] + b[1];\n  newDst[2] = r[2] + b[2];\n\n  return newDst;\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n *\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @param dst - The vector to set. If not passed a new one is created.\n * @returns {vec3} out\n */\nfunction rotateZ<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n  const p = [];\n  const r = [];\n\n  // translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  // perform rotation\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2];\n\n  // translate to correct position\n  newDst[0] = r[0] + b[0];\n  newDst[1] = r[1] + b[1];\n  newDst[2] = r[2] + b[2];\n\n  return newDst;\n}\n\n/**\n * Treat a 3D vector as a direction and set it's length\n *\n * @param a The vec3 to lengthen\n * @param len The length of the resulting vector\n * @returns The lengthened vector\n */\nfunction setLength<T extends Vec3Arg = VecType>(a: Vec3Arg, len: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n  normalize(a, newDst);\n  return mulScalar(newDst, len, newDst);\n}\n\n/**\n * Ensure a vector is not longer than a max length\n *\n * @param a The vec3 to limit\n * @param maxLen The longest length of the resulting vector\n * @returns The vector, shortened to maxLen if it's too long\n */\nfunction truncate<T extends Vec3Arg = VecType>(a: Vec3Arg, maxLen: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n\n  if (length(a) > maxLen) {\n    return setLength(a, maxLen, newDst);\n  }\n\n  return copy(a, newDst);\n}\n\n/**\n * Return the vector exactly between 2 endpoint vectors\n *\n * @param a Endpoint 1\n * @param b Endpoint 2\n * @returns The vector exactly residing between endpoints 1 and 2\n */\nfunction midpoint<T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(3)) as T;\n  return lerp(a, b, 0.5, newDst);\n}\n\nreturn {\n  create,\n  fromValues,\n  set,\n  ceil,\n  floor,\n  round,\n  clamp,\n  add,\n  addScaled,\n  angle,\n  subtract,\n  sub,\n  equalsApproximately,\n  equals,\n  lerp,\n  lerpV,\n  max,\n  min,\n  mulScalar,\n  scale,\n  divScalar,\n  inverse,\n  invert,\n  cross,\n  dot,\n  length,\n  len,\n  lengthSq,\n  lenSq,\n  distance,\n  dist,\n  distanceSq,\n  distSq,\n  normalize,\n  negate,\n  copy,\n  clone,\n  multiply,\n  mul,\n  divide,\n  div,\n  random,\n  zero,\n  transformMat4,\n  transformMat4Upper3x3,\n  transformMat3,\n  transformQuat,\n  getTranslation,\n  getAxis,\n  getScaling,\n  rotateX,\n  rotateY,\n  rotateZ,\n  setLength,\n  truncate,\n  midpoint,\n};\n\n}\n\ntype API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;\n\nconst cache = new Map();\n\nexport function getAPI<T extends Mat4Arg = Float32Array>(Ctor: Vec3Ctor<T>) {\n  let api = cache.get(Ctor);\n  if (!api) {\n    api = getAPIImpl<T>(Ctor);\n    cache.set(Ctor, api);\n  }\n  return api as API<T>;\n}\n", "/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nimport * as utils from './utils.js';\nimport { QuatArg } from './quat';\nimport { Mat3Arg, Mat3Type } from './mat3';\nimport { Mat4Arg } from './mat4';\nimport { Vec2Arg } from './vec2';\nimport { Vec3Arg } from './vec3';\nimport { getAPI as getVec2API } from './vec2-impl';\nimport { getAPI as getVec3API } from './vec3-impl';\nimport { BaseArgType } from './types';\n\nexport { Mat3Arg, Mat3Type };\n\ntype Mat3Ctor<T extends Mat3Arg = Float32Array>  = new (n: number) => T;\n\n/**\n * Generates a typed API for Mat3\n * */\nfunction getAPIImpl<MatType extends Mat3Arg = Float32Array>(Ctor: Mat3Ctor<MatType>) {\n  const vec2 = getVec2API<MatType>(Ctor);\n  const vec3 = getVec3API<MatType>(Ctor);\n\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create(\n    v0?: number, v1?: number, v2?: number,\n    v3?: number, v4?: number, v5?: number,\n    v6?: number, v7?: number, v8?: number) {\n  const newDst = new Ctor(12);\n  // to make the array homogenous\n  newDst[3] = 0;\n  newDst[7] = 0;\n  newDst[11] = 0;\n\n  if (v0 !== undefined) {\n    newDst[0] = v0;\n    if (v1 !== undefined) {\n      newDst[1] = v1;\n      if (v2 !== undefined) {\n        newDst[2] = v2;\n        if (v3 !== undefined) {\n          newDst[4] = v3;\n          if (v4 !== undefined) {\n            newDst[5] = v4;\n            if (v5 !== undefined) {\n              newDst[6] = v5;\n              if (v6 !== undefined) {\n                newDst[8] = v6;\n                if (v7 !== undefined) {\n                  newDst[9] = v7;\n                  if (v8 !== undefined) {\n                    newDst[10] = v8;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return newDst;\n}\n\n/**\n * Sets the values of a Mat3\n * Also see {@link mat3.create} and {@link mat3.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 set from values.\n */\nfunction set<T extends Mat3Arg = MatType>(\n    v0: number, v1: number, v2: number,\n    v3: number, v4: number, v5: number,\n    v6: number, v7: number, v8: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[0] = v0;  newDst[1] = v1;  newDst[ 2] = v2;  newDst[ 3] = 0;\n  newDst[4] = v3;  newDst[5] = v4;  newDst[ 6] = v5;  newDst[ 7] = 0;\n  newDst[8] = v6;  newDst[9] = v7;  newDst[10] = v8;  newDst[11] = 0;\n\n  return newDst;\n}\n\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4<T extends Mat3Arg = MatType>(m4: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n  newDst[0] = m4[0];  newDst[1] = m4[1];  newDst[ 2] = m4[ 2];  newDst[ 3] = 0;\n  newDst[4] = m4[4];  newDst[5] = m4[5];  newDst[ 6] = m4[ 6];  newDst[ 7] = 0;\n  newDst[8] = m4[8];  newDst[9] = m4[9];  newDst[10] = m4[10];  newDst[11] = 0;\n  return newDst;\n}\n\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat<T extends Mat3Arg = MatType>(q: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const x = q[0]; const y = q[1]; const z = q[2]; const w = q[3];\n  const x2 = x + x; const y2 = y + y; const z2 = z + z;\n\n  const xx = x * x2;\n  const yx = y * x2;\n  const yy = y * y2;\n  const zx = z * x2;\n  const zy = z * y2;\n  const zz = z * z2;\n  const wx = w * x2;\n  const wy = w * y2;\n  const wz = w * z2;\n\n  newDst[ 0] = 1 - yy - zz;  newDst[ 1] = yx + wz;      newDst[ 2] = zx - wy;      newDst[ 3] = 0;\n  newDst[ 4] = yx - wz;      newDst[ 5] = 1 - xx - zz;  newDst[ 6] = zy + wx;      newDst[ 7] = 0;\n  newDst[ 8] = zx + wy;      newDst[ 9] = zy - wx;      newDst[10] = 1 - xx - yy;  newDst[11] = 0;\n\n  return newDst;\n}\n\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate<T extends Mat3Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = -m[ 0];  newDst[ 1] = -m[ 1];  newDst[ 2] = -m[ 2];\n  newDst[ 4] = -m[ 4];  newDst[ 5] = -m[ 5];  newDst[ 6] = -m[ 6];\n  newDst[ 8] = -m[ 8];  newDst[ 9] = -m[ 9];  newDst[10] = -m[10];\n\n  return newDst;\n}\n\n/**\n * multiply a matrix by a scalar matrix.\n * @param m - The matrix.\n * @param s - the scalar\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns m * s.\n */\nfunction multiplyScalar<T extends Mat3Arg = MatType>(m: Mat3Arg, s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = m[ 0] * s;  newDst[ 1] = m[ 1] * s;  newDst[ 2] = m[ 2] * s;\n  newDst[ 4] = m[ 4] * s;  newDst[ 5] = m[ 5] * s;  newDst[ 6] = m[ 6] * s;\n  newDst[ 8] = m[ 8] * s;  newDst[ 9] = m[ 9] * s;  newDst[10] = m[10] * s;\n\n  return newDst;\n}\n\n/**\n * multiply a matrix by a scalar matrix.\n * @param m - The matrix.\n * @param s - the scalar\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns m * s.\n */\nconst mulScalar = multiplyScalar;\n\n/**\n * add 2 matrices.\n * @param a - matrix 1.\n * @param b - matrix 2.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns a + b.\n */\nfunction add<T extends Mat3Arg = MatType>(a: Mat3Arg, b: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = a[ 0] + b[ 0];  newDst[ 1] = a[ 1] + b[ 1];  newDst[ 2] = a[ 2] + b[ 2];\n  newDst[ 4] = a[ 4] + b[ 4];  newDst[ 5] = a[ 5] + b[ 5];  newDst[ 6] = a[ 6] + b[ 6];\n  newDst[ 8] = a[ 8] + b[ 8];  newDst[ 9] = a[ 9] + b[ 9];  newDst[10] = a[10] + b[10];\n\n  return newDst;\n}\n\n/**\n * Copies a matrix. (same as {@link mat3.clone})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy<T extends Mat3Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = m[ 0];  newDst[ 1] = m[ 1];  newDst[ 2] = m[ 2];\n  newDst[ 4] = m[ 4];  newDst[ 5] = m[ 5];  newDst[ 6] = m[ 6];\n  newDst[ 8] = m[ 8];  newDst[ 9] = m[ 9];  newDst[10] = m[10];\n\n  return newDst;\n}\n\n/**\n * Copies a matrix (same as {@link mat3.copy})\n * Also see {@link mat3.create} and {@link mat3.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone = copy;\n\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately(a: Mat3Arg, b: Mat3Arg): boolean {\n  return Math.abs(a[ 0] - b[ 0]) < utils.EPSILON &&\n         Math.abs(a[ 1] - b[ 1]) < utils.EPSILON &&\n         Math.abs(a[ 2] - b[ 2]) < utils.EPSILON &&\n         Math.abs(a[ 4] - b[ 4]) < utils.EPSILON &&\n         Math.abs(a[ 5] - b[ 5]) < utils.EPSILON &&\n         Math.abs(a[ 6] - b[ 6]) < utils.EPSILON &&\n         Math.abs(a[ 8] - b[ 8]) < utils.EPSILON &&\n         Math.abs(a[ 9] - b[ 9]) < utils.EPSILON &&\n         Math.abs(a[10] - b[10]) < utils.EPSILON;\n}\n\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals(a: Mat3Arg, b: Mat3Arg): boolean {\n  return a[ 0] === b[ 0] &&\n         a[ 1] === b[ 1] &&\n         a[ 2] === b[ 2] &&\n         a[ 4] === b[ 4] &&\n         a[ 5] === b[ 5] &&\n         a[ 6] === b[ 6] &&\n         a[ 8] === b[ 8] &&\n         a[ 9] === b[ 9] &&\n         a[10] === b[10];\n}\n\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity<T extends Mat3Arg = MatType>(dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = 1;  newDst[ 1] = 0;  newDst[ 2] = 0;\n  newDst[ 4] = 0;  newDst[ 5] = 1;  newDst[ 6] = 0;\n  newDst[ 8] = 0;  newDst[ 9] = 0;  newDst[10] = 1;\n\n  return newDst;\n}\n\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose<T extends Mat3Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n  if (newDst === m) {\n    let t: number;\n\n    // 0 1 2\n    // 4 5 6\n    // 8 9 10\n\n    t = m[1];\n    m[1] = m[4];\n    m[4] = t;\n\n    t = m[2];\n    m[2] = m[8];\n    m[8] = t;\n\n    t = m[6];\n    m[6] = m[9];\n    m[9] = t;\n\n    return newDst;\n  }\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n\n  newDst[ 0] = m00;  newDst[ 1] = m10;  newDst[ 2] = m20;\n  newDst[ 4] = m01;  newDst[ 5] = m11;  newDst[ 6] = m21;\n  newDst[ 8] = m02;  newDst[ 9] = m12;  newDst[10] = m22;\n\n  return newDst;\n}\n\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse<T extends Mat3Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n\n  const b01 =  m22 * m11 - m12 * m21;\n  const b11 = -m22 * m10 + m12 * m20;\n  const b21 =  m21 * m10 - m11 * m20;\n\n  const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n\n  newDst[ 0] = b01 * invDet;\n  newDst[ 1] = (-m22 * m01 + m02 * m21) * invDet;\n  newDst[ 2] = ( m12 * m01 - m02 * m11) * invDet;\n  newDst[ 4] = b11 * invDet;\n  newDst[ 5] = ( m22 * m00 - m02 * m20) * invDet;\n  newDst[ 6] = (-m12 * m00 + m02 * m10) * invDet;\n  newDst[ 8] = b21 * invDet;\n  newDst[ 9] = (-m21 * m00 + m01 * m20) * invDet;\n  newDst[10] = ( m11 * m00 - m01 * m10) * invDet;\n\n  return newDst;\n}\n\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m: Mat3Arg): number {\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n\n  return m00 * (m11 * m22 - m21 * m12) -\n         m10 * (m01 * m22 - m21 * m02) +\n         m20 * (m01 * m12 - m11 * m02);\n}\n\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert = inverse;\n\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply<T extends Mat3Arg = MatType>(a: Mat3Arg, b: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const a00 = a[0];\n  const a01 = a[1];\n  const a02 = a[2];\n  const a10 = a[ 4 + 0];\n  const a11 = a[ 4 + 1];\n  const a12 = a[ 4 + 2];\n  const a20 = a[ 8 + 0];\n  const a21 = a[ 8 + 1];\n  const a22 = a[ 8 + 2];\n  const b00 = b[0];\n  const b01 = b[1];\n  const b02 = b[2];\n  const b10 = b[ 4 + 0];\n  const b11 = b[ 4 + 1];\n  const b12 = b[ 4 + 2];\n  const b20 = b[ 8 + 0];\n  const b21 = b[ 8 + 1];\n  const b22 = b[ 8 + 2];\n\n  newDst[ 0] = a00 * b00 + a10 * b01 + a20 * b02;\n  newDst[ 1] = a01 * b00 + a11 * b01 + a21 * b02;\n  newDst[ 2] = a02 * b00 + a12 * b01 + a22 * b02;\n  newDst[ 4] = a00 * b10 + a10 * b11 + a20 * b12;\n  newDst[ 5] = a01 * b10 + a11 * b11 + a21 * b12;\n  newDst[ 6] = a02 * b10 + a12 * b11 + a22 * b12;\n  newDst[ 8] = a00 * b20 + a10 * b21 + a20 * b22;\n  newDst[ 9] = a01 * b20 + a11 * b21 + a21 * b22;\n  newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n\n  return newDst;\n}\n\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul = multiply;\n\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation<T extends Mat3Arg = MatType>(a: Mat3Arg, v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? identity()) as T;\n  if (a !== newDst) {\n    newDst[ 0] = a[ 0];\n    newDst[ 1] = a[ 1];\n    newDst[ 2] = a[ 2];\n    newDst[ 4] = a[ 4];\n    newDst[ 5] = a[ 5];\n    newDst[ 6] = a[ 6];\n  }\n  newDst[ 8] = v[0];\n  newDst[ 9] = v[1];\n  newDst[10] = 1;\n  return newDst;\n}\n\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation<T extends Vec2Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? vec2.create()) as T;\n  newDst[0] = m[8];\n  newDst[1] = m[9];\n  return newDst;\n}\n\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis<T extends Vec2Arg = MatType>(m: Mat3Arg, axis: number, dst?: T) {\n  const newDst = (dst ?? vec2.create()) as T;\n  const off = axis * 4;\n  newDst[0] = m[off + 0];\n  newDst[1] = m[off + 1];\n  return newDst;\n}\n\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis<T extends Mat3Arg = MatType>(m: Mat3Arg, v: Vec2Arg, axis: number, dst?: T) {\n  const newDst = (dst === m ? m : copy(m, dst)) as T;\n\n  const off = axis * 4;\n  newDst[off + 0] = v[0];\n  newDst[off + 1] = v[1];\n  return newDst;\n}\n\n/**\n * Returns the \"2d\" scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling<T extends Vec2Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? vec2.create());\n\n  const xx = m[0];\n  const xy = m[1];\n  const yx = m[4];\n  const yy = m[5];\n\n  newDst[0] = Math.sqrt(xx * xx + xy * xy);\n  newDst[1] = Math.sqrt(yx * yx + yy * yy);\n\n  return newDst;\n}\n\n\n/**\n * Returns the \"3d\" scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction get3DScaling<T extends Vec3Arg = MatType>(m: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? vec3.create());\n\n  const xx = m[0];\n  const xy = m[1];\n  const xz = m[2];\n  const yx = m[4];\n  const yy = m[5];\n  const yz = m[6];\n  const zx = m[8];\n  const zy = m[9];\n  const zz = m[10];\n\n  newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n  newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n  newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation<T extends Mat3Arg = MatType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = 1;     newDst[ 1] = 0;     newDst[ 2] = 0;\n  newDst[ 4] = 0;     newDst[ 5] = 1;     newDst[ 6] = 0;\n  newDst[ 8] = v[0];  newDst[ 9] = v[1];  newDst[10] = 1;\n\n  return newDst;\n}\n\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate<T extends Mat3Arg = MatType>(m: Mat3Arg, v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n\n  const m00 = m[0];\n  const m01 = m[1];\n  const m02 = m[2];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n\n  if (m !== newDst) {\n    newDst[ 0] = m00;\n    newDst[ 1] = m01;\n    newDst[ 2] = m02;\n    newDst[ 4] = m10;\n    newDst[ 5] = m11;\n    newDst[ 6] = m12;\n  }\n\n  newDst[ 8] = m00 * v0 + m10 * v1 + m20;\n  newDst[ 9] = m01 * v0 + m11 * v1 + m21;\n  newDst[10] = m02 * v0 + m12 * v1 + m22;\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation<T extends Mat3Arg = MatType>(angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] =  c;  newDst[ 1] = s;  newDst[ 2] = 0;\n  newDst[ 4] = -s;  newDst[ 5] = c;  newDst[ 6] = 0;\n  newDst[ 8] =  0;  newDst[ 9] = 0;  newDst[10] = 1;\n\n  return newDst;\n}\n\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate<T extends Mat3Arg = MatType>(m: Mat3Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = c * m00 + s * m10;\n  newDst[ 1] = c * m01 + s * m11;\n  newDst[ 2] = c * m02 + s * m12;\n\n  newDst[ 4] = c * m10 - s * m00;\n  newDst[ 5] = c * m11 - s * m01;\n  newDst[ 6] = c * m12 - s * m02;\n\n\n  if (m !== newDst) {\n    newDst[ 8] = m[ 8];\n    newDst[ 9] = m[ 9];\n    newDst[10] = m[10];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX<T extends Mat3Arg = MatType>(angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = 1;  newDst[ 1] =  0;  newDst[ 2] = 0;\n  newDst[ 4] = 0;  newDst[ 5] =  c;  newDst[ 6] = s;\n  newDst[ 8] = 0;  newDst[ 9] = -s;  newDst[10] = c;\n\n  return newDst;\n}\n\n/**\n * Rotates the given 3-by-3 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX<T extends Mat3Arg = MatType>(m: Mat3Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const m10 = m[4];\n  const m11 = m[5];\n  const m12 = m[6];\n  const m20 = m[8];\n  const m21 = m[9];\n  const m22 = m[10];\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[4]  = c * m10 + s * m20;\n  newDst[5]  = c * m11 + s * m21;\n  newDst[6]  = c * m12 + s * m22;\n  newDst[8]  = c * m20 - s * m10;\n  newDst[9]  = c * m21 - s * m11;\n  newDst[10] = c * m22 - s * m12;\n\n  if (m !== newDst) {\n    newDst[ 0] = m[ 0];\n    newDst[ 1] = m[ 1];\n    newDst[ 2] = m[ 2];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY<T extends Mat3Arg = MatType>(angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = c;  newDst[ 1] = 0;  newDst[ 2] = -s;\n  newDst[ 4] = 0;  newDst[ 5] = 1;  newDst[ 6] =  0;\n  newDst[ 8] = s;  newDst[ 9] = 0;  newDst[10] =  c;\n\n  return newDst;\n}\n\n/**\n * Rotates the given 3-by-3 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY<T extends Mat3Arg = MatType>(m: Mat3Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = c * m00 - s * m20;\n  newDst[ 1] = c * m01 - s * m21;\n  newDst[ 2] = c * m02 - s * m22;\n  newDst[ 8] = c * m20 + s * m00;\n  newDst[ 9] = c * m21 + s * m01;\n  newDst[10] = c * m22 + s * m02;\n\n  if (m !== newDst) {\n    newDst[ 4] = m[ 4];\n    newDst[ 5] = m[ 5];\n    newDst[ 6] = m[ 6];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nconst rotationZ = rotation;\n\n/**\n * Rotates the given 3-by-3 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotateZ = rotate;\n\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has two\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling<T extends Mat3Arg = MatType>(v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = v[0];  newDst[ 1] = 0;     newDst[ 2] = 0;\n  newDst[ 4] = 0;     newDst[ 5] = v[1];  newDst[ 6] = 0;\n  newDst[ 8] = 0;     newDst[ 9] = 0;     newDst[10] = 1;\n\n  return newDst;\n}\n\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * two entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale<T extends Mat3Arg = MatType>(m: Mat3Arg, v: Vec2Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n\n  newDst[ 0] = v0 * m[0 * 4 + 0];\n  newDst[ 1] = v0 * m[0 * 4 + 1];\n  newDst[ 2] = v0 * m[0 * 4 + 2];\n\n  newDst[ 4] = v1 * m[1 * 4 + 0];\n  newDst[ 5] = v1 * m[1 * 4 + 1];\n  newDst[ 6] = v1 * m[1 * 4 + 2];\n\n  if (m !== newDst) {\n    newDst[ 8] = m[ 8];\n    newDst[ 9] = m[ 9];\n    newDst[10] = m[10];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     3 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling3D<T extends Mat3Arg = MatType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = v[0];  newDst[ 1] = 0;     newDst[ 2] = 0;\n  newDst[ 4] = 0;     newDst[ 5] = v[1];  newDst[ 6] = 0;\n  newDst[ 8] = 0;     newDst[ 9] = 0;     newDst[10] = v[2];\n\n  return newDst;\n}\n\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 3 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale3D<T extends Mat3Arg = MatType>(m: Mat3Arg, v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n\n  newDst[ 0] = v0 * m[0 * 4 + 0];\n  newDst[ 1] = v0 * m[0 * 4 + 1];\n  newDst[ 2] = v0 * m[0 * 4 + 2];\n\n  newDst[ 4] = v1 * m[1 * 4 + 0];\n  newDst[ 5] = v1 * m[1 * 4 + 1];\n  newDst[ 6] = v1 * m[1 * 4 + 2];\n\n  newDst[ 8] = v2 * m[2 * 4 + 0];\n  newDst[ 9] = v2 * m[2 * 4 + 1];\n  newDst[10] = v2 * m[2 * 4 + 2];\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which scales uniformly in the X and Y dimensions\n * @param s - Amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling<T extends Mat3Arg = MatType>(s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = s;  newDst[ 1] = 0;  newDst[ 2] = 0;\n  newDst[ 4] = 0;  newDst[ 5] = s;  newDst[ 6] = 0;\n  newDst[ 8] = 0;  newDst[ 9] = 0;  newDst[10] = 1;\n\n  return newDst;\n}\n\n/**\n * Scales the given 3-by-3 matrix in the X and Y dimension by an amount\n * given.\n * @param m - The matrix to be modified.\n * @param s - Amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale<T extends Mat3Arg = MatType>(m: Mat3Arg, s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = s * m[0 * 4 + 0];\n  newDst[ 1] = s * m[0 * 4 + 1];\n  newDst[ 2] = s * m[0 * 4 + 2];\n\n  newDst[ 4] = s * m[1 * 4 + 0];\n  newDst[ 5] = s * m[1 * 4 + 1];\n  newDst[ 6] = s * m[1 * 4 + 2];\n\n  if (m !== newDst) {\n    newDst[ 8] = m[ 8];\n    newDst[ 9] = m[ 9];\n    newDst[10] = m[10];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 3-by-3 matrix which scales uniformly in each dimension\n * @param s - Amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling3D<T extends Mat3Arg = MatType>(s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = s;  newDst[ 1] = 0;  newDst[ 2] = 0;\n  newDst[ 4] = 0;  newDst[ 5] = s;  newDst[ 6] = 0;\n  newDst[ 8] = 0;  newDst[ 9] = 0;  newDst[10] = s;\n\n  return newDst;\n}\n\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given.\n * @param m - The matrix to be modified.\n * @param s - Amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale3D<T extends Mat3Arg = MatType>(m: Mat3Arg, s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(12)) as T;\n\n  newDst[ 0] = s * m[0 * 4 + 0];\n  newDst[ 1] = s * m[0 * 4 + 1];\n  newDst[ 2] = s * m[0 * 4 + 2];\n\n  newDst[ 4] = s * m[1 * 4 + 0];\n  newDst[ 5] = s * m[1 * 4 + 1];\n  newDst[ 6] = s * m[1 * 4 + 2];\n\n  newDst[ 8] = s * m[2 * 4 + 0];\n  newDst[ 9] = s * m[2 * 4 + 1];\n  newDst[10] = s * m[2 * 4 + 2];\n\n  return newDst;\n}\n\nreturn {\n  add,\n  clone,\n  copy,\n  create,\n  determinant,\n  equals,\n  equalsApproximately,\n  fromMat4,\n  fromQuat,\n  get3DScaling,\n  getAxis,\n  getScaling,\n  getTranslation,\n  identity,\n  inverse,\n  invert,\n  mul,\n  mulScalar,\n  multiply,\n  multiplyScalar,\n  negate,\n  rotate,\n  rotateX,\n  rotateY,\n  rotateZ,\n  rotation,\n  rotationX,\n  rotationY,\n  rotationZ,\n  scale,\n  scale3D,\n  scaling,\n  scaling3D,\n  set,\n  setAxis,\n  setTranslation,\n  translate,\n  translation,\n  transpose,\n  uniformScale,\n  uniformScale3D,\n  uniformScaling,\n  uniformScaling3D,\n};\n\n}\n\ntype API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;\n\nconst cache = new Map();\n\nexport function getAPI<T extends Mat4Arg = Float32Array>(Ctor: Mat3Ctor<T>) {\n  let api = cache.get(Ctor);\n  if (!api) {\n    api = getAPIImpl<T>(Ctor);\n    cache.set(Ctor, api);\n  }\n  return api as API<T>;\n}\n", "import { Mat4Arg, Mat4Type } from './mat4';\nimport { Mat3Arg } from './mat3';\nimport { QuatArg } from './quat';\nimport { Vec3Arg } from './vec3';\nimport { getAPI as getVec3API } from './vec3-impl';\nimport { BaseArgType } from './types';\nimport * as utils from './utils';\n\nexport { Mat4Arg, Mat4Type };\n\ntype Mat4Ctor<T extends Mat4Arg = Float32Array>  = new (n: number) => T;\n\n/**\n * Generates a typed API for Mat4\n * */\nfunction getAPIImpl<MatType extends Mat4Arg = Float32Array>(Ctor: Mat4Ctor<MatType>) {\n  const vec3 = getVec3API<MatType>(Ctor);\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\n\n\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create(\n    v0?: number, v1?: number, v2?: number, v3?: number,\n    v4?: number, v5?: number, v6?: number, v7?: number,\n    v8?: number, v9?: number, v10?: number, v11?: number,\n    v12?: number, v13?: number, v14?: number, v15?: number) {\n  const newDst = new Ctor(16);\n  if (v0 !== undefined) {\n    newDst[0] = v0;\n    if (v1 !== undefined) {\n      newDst[1] = v1;\n      if (v2 !== undefined) {\n        newDst[2] = v2;\n        if (v3 !== undefined) {\n          newDst[3] = v3;\n          if (v4 !== undefined) {\n            newDst[4] = v4;\n            if (v5 !== undefined) {\n              newDst[5] = v5;\n              if (v6 !== undefined) {\n                newDst[6] = v6;\n                if (v7 !== undefined) {\n                  newDst[7] = v7;\n                  if (v8 !== undefined) {\n                    newDst[8] = v8;\n                    if (v9 !== undefined) {\n                      newDst[9] = v9;\n                      if (v10 !== undefined) {\n                        newDst[10] = v10;\n                        if (v11 !== undefined) {\n                          newDst[11] = v11;\n                          if (v12 !== undefined) {\n                            newDst[12] = v12;\n                            if (v13 !== undefined) {\n                              newDst[13] = v13;\n                              if (v14 !== undefined) {\n                                newDst[14] = v14;\n                                if (v15 !== undefined) {\n                                  newDst[15] = v15;\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return newDst;\n}\n\n/**\n * Sets the values of a Mat4\n * Also see {@link mat4.create} and {@link mat4.copy}\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 created from values.\n */\nfunction set<T extends Mat4Arg = MatType>(\n    v0: number, v1: number, v2: number, v3: number,\n    v4: number, v5: number, v6: number, v7: number,\n    v8: number, v9: number, v10: number, v11: number,\n    v12: number, v13: number, v14: number, v15: number,\n    dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = v0;   newDst[ 1] = v1;   newDst[ 2] = v2;   newDst[ 3] = v3;\n  newDst[ 4] = v4;   newDst[ 5] = v5;   newDst[ 6] = v6;   newDst[ 7] = v7;\n  newDst[ 8] = v8;   newDst[ 9] = v9;   newDst[10] = v10;  newDst[11] = v11;\n  newDst[12] = v12;  newDst[13] = v13;  newDst[14] = v14;  newDst[15] = v15;\n\n  return newDst;\n}\n\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3<T extends Mat4Arg = MatType>(m3: Mat3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = m3[0];  newDst[ 1] = m3[1];  newDst[ 2] = m3[ 2];  newDst[ 3] = 0;\n  newDst[ 4] = m3[4];  newDst[ 5] = m3[5];  newDst[ 6] = m3[ 6];  newDst[ 7] = 0;\n  newDst[ 8] = m3[8];  newDst[ 9] = m3[9];  newDst[10] = m3[10];  newDst[11] = 0;\n  newDst[12] = 0;      newDst[13] = 0;      newDst[14] = 0;       newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat<T extends Mat4Arg = MatType>(q: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const x = q[0]; const y = q[1]; const z = q[2]; const w = q[3];\n  const x2 = x + x; const y2 = y + y; const z2 = z + z;\n\n  const xx = x * x2;\n  const yx = y * x2;\n  const yy = y * y2;\n  const zx = z * x2;\n  const zy = z * y2;\n  const zz = z * z2;\n  const wx = w * x2;\n  const wy = w * y2;\n  const wz = w * z2;\n\n  newDst[ 0] = 1 - yy - zz;  newDst[ 1] = yx + wz;      newDst[ 2] = zx - wy;      newDst[ 3] = 0;\n  newDst[ 4] = yx - wz;      newDst[ 5] = 1 - xx - zz;  newDst[ 6] = zy + wx;      newDst[ 7] = 0;\n  newDst[ 8] = zx + wy;      newDst[ 9] = zy - wx;      newDst[10] = 1 - xx - yy;  newDst[11] = 0;\n  newDst[12] = 0;            newDst[13] = 0;            newDst[14] = 0;            newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate<T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = -m[ 0];  newDst[ 1] = -m[ 1];  newDst[ 2] = -m[ 2];  newDst[ 3] = -m[ 3];\n  newDst[ 4] = -m[ 4];  newDst[ 5] = -m[ 5];  newDst[ 6] = -m[ 6];  newDst[ 7] = -m[ 7];\n  newDst[ 8] = -m[ 8];  newDst[ 9] = -m[ 9];  newDst[10] = -m[10];  newDst[11] = -m[11];\n  newDst[12] = -m[12];  newDst[13] = -m[13];  newDst[14] = -m[14];  newDst[15] = -m[15];\n\n  return newDst;\n}\n\n/**\n * add 2 matrices.\n * @param a - matrix 1.\n * @param b - matrix 2.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns a + b.\n */\nfunction add<T extends Mat4Arg = MatType>(a: Mat4Arg, b: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = a[ 0] + b[ 0];  newDst[ 1] = a[ 1] + b[ 1];  newDst[ 2] = a[ 2] + b[ 2];  newDst[ 3] = a[ 3] + b[ 3];\n  newDst[ 4] = a[ 4] + b[ 4];  newDst[ 5] = a[ 5] + b[ 5];  newDst[ 6] = a[ 6] + b[ 6];  newDst[ 7] = a[ 7] + b[ 7];\n  newDst[ 8] = a[ 8] + b[ 8];  newDst[ 9] = a[ 9] + b[ 9];  newDst[10] = a[10] + b[10];  newDst[11] = a[11] + b[11];\n  newDst[12] = a[12] + b[12];  newDst[13] = a[13] + b[13];  newDst[14] = a[14] + b[14];  newDst[15] = a[15] + b[15];\n\n  return newDst;\n}\n\n/**\n * Multiplies a matrix by a scalar\n * @param m - The matrix.\n * @param s - The scalar\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns m * s.\n */\nfunction multiplyScalar<T extends Mat4Arg = MatType>(m: Mat4Arg, s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = m[ 0] * s;  newDst[ 1] = m[ 1] * s;  newDst[ 2] = m[ 2] * s;  newDst[ 3] = m[ 3] * s;\n  newDst[ 4] = m[ 4] * s;  newDst[ 5] = m[ 5] * s;  newDst[ 6] = m[ 6] * s;  newDst[ 7] = m[ 7] * s;\n  newDst[ 8] = m[ 8] * s;  newDst[ 9] = m[ 9] * s;  newDst[10] = m[10] * s;  newDst[11] = m[11] * s;\n  newDst[12] = m[12] * s;  newDst[13] = m[13] * s;  newDst[14] = m[14] * s;  newDst[15] = m[15] * s;\n\n  return newDst;\n}\n\n/**\n * Multiplies a matrix by a scalar\n * @param m - The matrix.\n * @param s - The scalar\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns m * s.\n */\nconst mulScalar = multiplyScalar;\n\n/**\n * Copies a matrix. (same as {@link mat4.clone})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy<T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = m[ 0];  newDst[ 1] = m[ 1];  newDst[ 2] = m[ 2];  newDst[ 3] = m[ 3];\n  newDst[ 4] = m[ 4];  newDst[ 5] = m[ 5];  newDst[ 6] = m[ 6];  newDst[ 7] = m[ 7];\n  newDst[ 8] = m[ 8];  newDst[ 9] = m[ 9];  newDst[10] = m[10];  newDst[11] = m[11];\n  newDst[12] = m[12];  newDst[13] = m[13];  newDst[14] = m[14];  newDst[15] = m[15];\n\n  return newDst;\n}\n\n/**\n * Copies a matrix (same as {@link mat4.copy})\n * Also see {@link mat4.create} and {@link mat4.set}\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone = copy;\n\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately(a: Mat4Arg, b: Mat4Arg): boolean {\n  return Math.abs(a[ 0] - b[ 0]) < utils.EPSILON &&\n         Math.abs(a[ 1] - b[ 1]) < utils.EPSILON &&\n         Math.abs(a[ 2] - b[ 2]) < utils.EPSILON &&\n         Math.abs(a[ 3] - b[ 3]) < utils.EPSILON &&\n         Math.abs(a[ 4] - b[ 4]) < utils.EPSILON &&\n         Math.abs(a[ 5] - b[ 5]) < utils.EPSILON &&\n         Math.abs(a[ 6] - b[ 6]) < utils.EPSILON &&\n         Math.abs(a[ 7] - b[ 7]) < utils.EPSILON &&\n         Math.abs(a[ 8] - b[ 8]) < utils.EPSILON &&\n         Math.abs(a[ 9] - b[ 9]) < utils.EPSILON &&\n         Math.abs(a[10] - b[10]) < utils.EPSILON &&\n         Math.abs(a[11] - b[11]) < utils.EPSILON &&\n         Math.abs(a[12] - b[12]) < utils.EPSILON &&\n         Math.abs(a[13] - b[13]) < utils.EPSILON &&\n         Math.abs(a[14] - b[14]) < utils.EPSILON &&\n         Math.abs(a[15] - b[15]) < utils.EPSILON;\n}\n\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals(a: Mat4Arg, b: Mat4Arg): boolean {\n  return a[ 0] === b[ 0] &&\n         a[ 1] === b[ 1] &&\n         a[ 2] === b[ 2] &&\n         a[ 3] === b[ 3] &&\n         a[ 4] === b[ 4] &&\n         a[ 5] === b[ 5] &&\n         a[ 6] === b[ 6] &&\n         a[ 7] === b[ 7] &&\n         a[ 8] === b[ 8] &&\n         a[ 9] === b[ 9] &&\n         a[10] === b[10] &&\n         a[11] === b[11] &&\n         a[12] === b[12] &&\n         a[13] === b[13] &&\n         a[14] === b[14] &&\n         a[15] === b[15];\n}\n\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity<T extends Mat4Arg = MatType>(dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = 1;  newDst[ 1] = 0;  newDst[ 2] = 0;  newDst[ 3] = 0;\n  newDst[ 4] = 0;  newDst[ 5] = 1;  newDst[ 6] = 0;  newDst[ 7] = 0;\n  newDst[ 8] = 0;  newDst[ 9] = 0;  newDst[10] = 1;  newDst[11] = 0;\n  newDst[12] = 0;  newDst[13] = 0;  newDst[14] = 0;  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose<T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n  if (newDst === m) {\n    let t;\n\n    t = m[1];\n    m[1] = m[4];\n    m[4] = t;\n\n    t = m[2];\n    m[2] = m[8];\n    m[8] = t;\n\n    t = m[3];\n    m[3] = m[12];\n    m[12] = t;\n\n    t = m[6];\n    m[6] = m[9];\n    m[9] = t;\n\n    t = m[7];\n    m[7] = m[13];\n    m[13] = t;\n\n    t = m[11];\n    m[11] = m[14];\n    m[14] = t;\n    return newDst;\n  }\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m03 = m[0 * 4 + 3];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m13 = m[1 * 4 + 3];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const m23 = m[2 * 4 + 3];\n  const m30 = m[3 * 4 + 0];\n  const m31 = m[3 * 4 + 1];\n  const m32 = m[3 * 4 + 2];\n  const m33 = m[3 * 4 + 3];\n\n  newDst[ 0] = m00;  newDst[ 1] = m10;  newDst[ 2] = m20;  newDst[ 3] = m30;\n  newDst[ 4] = m01;  newDst[ 5] = m11;  newDst[ 6] = m21;  newDst[ 7] = m31;\n  newDst[ 8] = m02;  newDst[ 9] = m12;  newDst[10] = m22;  newDst[11] = m32;\n  newDst[12] = m03;  newDst[13] = m13;  newDst[14] = m23;  newDst[15] = m33;\n\n  return newDst;\n}\n\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse<T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m03 = m[0 * 4 + 3];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m13 = m[1 * 4 + 3];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const m23 = m[2 * 4 + 3];\n  const m30 = m[3 * 4 + 0];\n  const m31 = m[3 * 4 + 1];\n  const m32 = m[3 * 4 + 2];\n  const m33 = m[3 * 4 + 3];\n  const tmp0  = m22 * m33;\n  const tmp1  = m32 * m23;\n  const tmp2  = m12 * m33;\n  const tmp3  = m32 * m13;\n  const tmp4  = m12 * m23;\n  const tmp5  = m22 * m13;\n  const tmp6  = m02 * m33;\n  const tmp7  = m32 * m03;\n  const tmp8  = m02 * m23;\n  const tmp9  = m22 * m03;\n  const tmp10 = m02 * m13;\n  const tmp11 = m12 * m03;\n  const tmp12 = m20 * m31;\n  const tmp13 = m30 * m21;\n  const tmp14 = m10 * m31;\n  const tmp15 = m30 * m11;\n  const tmp16 = m10 * m21;\n  const tmp17 = m20 * m11;\n  const tmp18 = m00 * m31;\n  const tmp19 = m30 * m01;\n  const tmp20 = m00 * m21;\n  const tmp21 = m20 * m01;\n  const tmp22 = m00 * m11;\n  const tmp23 = m10 * m01;\n\n  const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n      (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n  const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n      (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n  const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n      (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n  const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n      (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n\n  const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n  newDst[ 0] = d * t0;\n  newDst[ 1] = d * t1;\n  newDst[ 2] = d * t2;\n  newDst[ 3] = d * t3;\n  newDst[ 4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n          (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n  newDst[ 5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n          (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n  newDst[ 6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n          (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n  newDst[ 7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n          (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n  newDst[ 8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n          (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n  newDst[ 9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n          (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n  newDst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n          (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n  newDst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n          (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n  newDst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n          (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n  newDst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n          (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n  newDst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n          (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n  newDst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n          (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n\n  return newDst;\n}\n\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m: Mat4Arg): number {\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m03 = m[0 * 4 + 3];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m13 = m[1 * 4 + 3];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const m23 = m[2 * 4 + 3];\n  const m30 = m[3 * 4 + 0];\n  const m31 = m[3 * 4 + 1];\n  const m32 = m[3 * 4 + 2];\n  const m33 = m[3 * 4 + 3];\n\n  const tmp0  = m22 * m33;\n  const tmp1  = m32 * m23;\n  const tmp2  = m12 * m33;\n  const tmp3  = m32 * m13;\n  const tmp4  = m12 * m23;\n  const tmp5  = m22 * m13;\n  const tmp6  = m02 * m33;\n  const tmp7  = m32 * m03;\n  const tmp8  = m02 * m23;\n  const tmp9  = m22 * m03;\n  const tmp10 = m02 * m13;\n  const tmp11 = m12 * m03;\n\n  const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n             (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n  const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n             (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n  const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n             (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n  const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n             (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n\n  return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert = inverse;\n\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply<T extends Mat4Arg = MatType>(a: Mat4Arg, b: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const a00 = a[0];\n  const a01 = a[1];\n  const a02 = a[2];\n  const a03 = a[3];\n  const a10 = a[ 4 + 0];\n  const a11 = a[ 4 + 1];\n  const a12 = a[ 4 + 2];\n  const a13 = a[ 4 + 3];\n  const a20 = a[ 8 + 0];\n  const a21 = a[ 8 + 1];\n  const a22 = a[ 8 + 2];\n  const a23 = a[ 8 + 3];\n  const a30 = a[12 + 0];\n  const a31 = a[12 + 1];\n  const a32 = a[12 + 2];\n  const a33 = a[12 + 3];\n  const b00 = b[0];\n  const b01 = b[1];\n  const b02 = b[2];\n  const b03 = b[3];\n  const b10 = b[ 4 + 0];\n  const b11 = b[ 4 + 1];\n  const b12 = b[ 4 + 2];\n  const b13 = b[ 4 + 3];\n  const b20 = b[ 8 + 0];\n  const b21 = b[ 8 + 1];\n  const b22 = b[ 8 + 2];\n  const b23 = b[ 8 + 3];\n  const b30 = b[12 + 0];\n  const b31 = b[12 + 1];\n  const b32 = b[12 + 2];\n  const b33 = b[12 + 3];\n\n  newDst[ 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n  newDst[ 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n  newDst[ 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n  newDst[ 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n  newDst[ 4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n  newDst[ 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n  newDst[ 6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n  newDst[ 7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n  newDst[ 8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n  newDst[ 9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n  newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n  newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n  newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n  newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n  newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n  newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n\n  return newDst;\n}\n\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul = multiply;\n\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation<T extends Mat4Arg = MatType>(a: Mat4Arg, v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? identity()) as T;\n  if (a !== newDst) {\n    newDst[ 0] = a[ 0];\n    newDst[ 1] = a[ 1];\n    newDst[ 2] = a[ 2];\n    newDst[ 3] = a[ 3];\n    newDst[ 4] = a[ 4];\n    newDst[ 5] = a[ 5];\n    newDst[ 6] = a[ 6];\n    newDst[ 7] = a[ 7];\n    newDst[ 8] = a[ 8];\n    newDst[ 9] = a[ 9];\n    newDst[10] = a[10];\n    newDst[11] = a[11];\n  }\n  newDst[12] = v[0];\n  newDst[13] = v[1];\n  newDst[14] = v[2];\n  newDst[15] = 1;\n  return newDst;\n}\n\n///**\n// * Returns the translation component of a 4-by-4 matrix as a vector with 3\n// * entries.\n// * @param m - The matrix.\n// * @param dst - vector to hold result. If not passed a new one is created.\n// * @returns The translation component of m.\n// */\nfunction getTranslation<T extends Vec3Arg = MatType>(m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? vec3.create()) as T;\n  newDst[0] = m[12];\n  newDst[1] = m[13];\n  newDst[2] = m[14];\n  return newDst;\n}\n\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis<T extends Vec3Arg = MatType>(m: Mat4Arg, axis: number, dst?: T) {\n  const newDst = (dst ?? vec3.create());\n  const off = axis * 4;\n  newDst[0] = m[off + 0];\n  newDst[1] = m[off + 1];\n  newDst[2] = m[off + 2];\n  return newDst;\n}\n\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis<T extends Mat4Arg = MatType>(m: Mat4Arg, v: Vec3Arg, axis: number, dst: T) {\n  const newDst = (dst === m) ? dst : copy(m, dst);\n\n  const off = axis * 4;\n  newDst[off + 0] = v[0];\n  newDst[off + 1] = v[1];\n  newDst[off + 2] = v[2];\n  return newDst;\n}\n\n/**\n * Returns the \"3d\" scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling<T extends Vec3Arg = MatType>(m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? vec3.create()) as T;\n\n  const xx = m[0];\n  const xy = m[1];\n  const xz = m[2];\n  const yx = m[4];\n  const yy = m[5];\n  const yz = m[6];\n  const zx = m[8];\n  const zy = m[9];\n  const zz = m[10];\n\n  newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n  newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n  newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective<T extends Mat4Arg = MatType>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n\n  newDst[0]  = f / aspect;\n  newDst[1]  = 0;\n  newDst[2]  = 0;\n  newDst[3]  = 0;\n\n  newDst[4]  = 0;\n  newDst[5]  = f;\n  newDst[6]  = 0;\n  newDst[7]  = 0;\n\n  newDst[8]  = 0;\n  newDst[9]  = 0;\n  newDst[11] = -1;\n\n  newDst[12] = 0;\n  newDst[13] = 0;\n  newDst[15] = 0;\n\n  if (Number.isFinite(zFar)) {\n    const rangeInv = 1 / (zNear - zFar);\n    newDst[10] = zFar * rangeInv;\n    newDst[14] = zFar * zNear * rangeInv;\n  } else {\n    newDst[10] = -1;\n    newDst[14] = -zNear;\n  }\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane. (default = Infinity)\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */function perspectiveReverseZ<T extends Mat4Arg = MatType>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar = Infinity, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);\n\n  newDst[ 0] = f / aspect;\n  newDst[ 1] = 0;\n  newDst[ 2] = 0;\n  newDst[ 3] = 0;\n\n  newDst[ 4] = 0;\n  newDst[ 5] = f;\n  newDst[ 6] = 0;\n  newDst[ 7] = 0;\n\n  newDst[ 8] = 0;\n  newDst[ 9] = 0;\n  newDst[11] = -1;\n\n  newDst[12] = 0;\n  newDst[13] = 0;\n  newDst[15] = 0;\n\n  if (zFar === Infinity) {\n    newDst[10] = 0;\n    newDst[14] = zNear;\n  } else {\n    const rangeInv = 1 / (zFar - zNear);\n    newDst[10] = zNear * rangeInv;\n    newDst[14] = zFar * zNear * rangeInv;\n  }\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho<T extends Mat4Arg = MatType>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[0]  = 2 / (right - left);\n  newDst[1]  = 0;\n  newDst[2]  = 0;\n  newDst[3]  = 0;\n\n  newDst[4]  = 0;\n  newDst[5]  = 2 / (top - bottom);\n  newDst[6]  = 0;\n  newDst[7]  = 0;\n\n  newDst[8]  = 0;\n  newDst[9]  = 0;\n  newDst[10] = 1 / (near - far);\n  newDst[11] = 0;\n\n  newDst[12] = (right + left) / (left - right);\n  newDst[13] = (top + bottom) / (bottom - top);\n  newDst[14] = near / (near - far);\n  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum<T extends Mat4Arg = MatType>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const dx = (right - left);\n  const dy = (top - bottom);\n  const dz = (near - far);\n\n  newDst[ 0] = 2 * near / dx;\n  newDst[ 1] = 0;\n  newDst[ 2] = 0;\n  newDst[ 3] = 0;\n  newDst[ 4] = 0;\n  newDst[ 5] = 2 * near / dy;\n  newDst[ 6] = 0;\n  newDst[ 7] = 0;\n  newDst[ 8] = (left + right) / dx;\n  newDst[ 9] = (top + bottom) / dy;\n  newDst[10] = far / dz;\n  newDst[11] = -1;\n  newDst[12] = 0;\n  newDst[13] = 0;\n  newDst[14] = near * far / dz;\n  newDst[15] = 0;\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustumReverseZ<T extends Mat4Arg = MatType>(left: number, right: number, bottom: number, top: number, near: number, far = Infinity, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const dx = (right - left);\n  const dy = (top - bottom);\n\n  newDst[ 0] = 2 * near / dx;\n  newDst[ 1] = 0;\n  newDst[ 2] = 0;\n  newDst[ 3] = 0;\n  newDst[ 4] = 0;\n  newDst[ 5] = 2 * near / dy;\n  newDst[ 6] = 0;\n  newDst[ 7] = 0;\n  newDst[ 8] = (left + right) / dx;\n  newDst[ 9] = (top + bottom) / dy;\n  newDst[11] = -1;\n  newDst[12] = 0;\n  newDst[13] = 0;\n  newDst[15] = 0;\n\n  if (far === Infinity) {\n    newDst[10] = 0;\n    newDst[14] = near;\n  } else {\n    const rangeInv = 1 / (far - near);\n    newDst[10] = near * rangeInv;\n    newDst[14] = far * near * rangeInv;\n  }\n\n  return newDst;\n}\n\nconst xAxis = vec3.create();\nconst yAxis = vec3.create();\nconst zAxis = vec3.create();\n\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim<T extends Mat4Arg = MatType>(position: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);\n  vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n  vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n\n  newDst[ 0] = xAxis[0];     newDst[ 1] = xAxis[1];     newDst[ 2] = xAxis[2];     newDst[ 3] = 0;\n  newDst[ 4] = yAxis[0];     newDst[ 5] = yAxis[1];     newDst[ 6] = yAxis[2];     newDst[ 7] = 0;\n  newDst[ 8] = zAxis[0];     newDst[ 9] = zAxis[1];     newDst[10] = zAxis[2];     newDst[11] = 0;\n  newDst[12] = position[0];  newDst[13] = position[1];  newDst[14] = position[2];  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim<T extends Mat4Arg = MatType>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n  vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n  vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n\n  newDst[ 0] = xAxis[0];     newDst[ 1] = xAxis[1];     newDst[ 2] = xAxis[2];     newDst[ 3] = 0;\n  newDst[ 4] = yAxis[0];     newDst[ 5] = yAxis[1];     newDst[ 6] = yAxis[2];     newDst[ 7] = 0;\n  newDst[ 8] = zAxis[0];     newDst[ 9] = zAxis[1];     newDst[10] = zAxis[2];     newDst[11] = 0;\n  newDst[12] = eye[0];  newDst[13] = eye[1];  newDst[14] = eye[2];  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt<T extends Mat4Arg = MatType>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n  vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n  vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n\n  newDst[ 0] = xAxis[0];  newDst[ 1] = yAxis[0];  newDst[ 2] = zAxis[0];  newDst[ 3] = 0;\n  newDst[ 4] = xAxis[1];  newDst[ 5] = yAxis[1];  newDst[ 6] = zAxis[1];  newDst[ 7] = 0;\n  newDst[ 8] = xAxis[2];  newDst[ 9] = yAxis[2];  newDst[10] = zAxis[2];  newDst[11] = 0;\n\n  newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n  newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n  newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation<T extends Mat4Arg = MatType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = 1;     newDst[ 1] = 0;     newDst[ 2] = 0;     newDst[ 3] = 0;\n  newDst[ 4] = 0;     newDst[ 5] = 1;     newDst[ 6] = 0;     newDst[ 7] = 0;\n  newDst[ 8] = 0;     newDst[ 9] = 0;     newDst[10] = 1;     newDst[11] = 0;\n  newDst[12] = v[0];  newDst[13] = v[1];  newDst[14] = v[2];  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate<T extends Mat4Arg = MatType>(m: Mat4Arg, v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const m00 = m[0];\n  const m01 = m[1];\n  const m02 = m[2];\n  const m03 = m[3];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m13 = m[1 * 4 + 3];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const m23 = m[2 * 4 + 3];\n  const m30 = m[3 * 4 + 0];\n  const m31 = m[3 * 4 + 1];\n  const m32 = m[3 * 4 + 2];\n  const m33 = m[3 * 4 + 3];\n\n  if (m !== newDst) {\n    newDst[ 0] = m00;\n    newDst[ 1] = m01;\n    newDst[ 2] = m02;\n    newDst[ 3] = m03;\n    newDst[ 4] = m10;\n    newDst[ 5] = m11;\n    newDst[ 6] = m12;\n    newDst[ 7] = m13;\n    newDst[ 8] = m20;\n    newDst[ 9] = m21;\n    newDst[10] = m22;\n    newDst[11] = m23;\n  }\n\n  newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n  newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n  newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n  newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX<T extends Mat4Arg = MatType>(angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = 1;  newDst[ 1] =  0;  newDst[ 2] = 0;  newDst[ 3] = 0;\n  newDst[ 4] = 0;  newDst[ 5] =  c;  newDst[ 6] = s;  newDst[ 7] = 0;\n  newDst[ 8] = 0;  newDst[ 9] = -s;  newDst[10] = c;  newDst[11] = 0;\n  newDst[12] = 0;  newDst[13] =  0;  newDst[14] = 0;  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX<T extends Mat4Arg = MatType>(m: Mat4Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const m10 = m[4];\n  const m11 = m[5];\n  const m12 = m[6];\n  const m13 = m[7];\n  const m20 = m[8];\n  const m21 = m[9];\n  const m22 = m[10];\n  const m23 = m[11];\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[4]  = c * m10 + s * m20;\n  newDst[5]  = c * m11 + s * m21;\n  newDst[6]  = c * m12 + s * m22;\n  newDst[7]  = c * m13 + s * m23;\n  newDst[8]  = c * m20 - s * m10;\n  newDst[9]  = c * m21 - s * m11;\n  newDst[10] = c * m22 - s * m12;\n  newDst[11] = c * m23 - s * m13;\n\n  if (m !== newDst) {\n    newDst[ 0] = m[ 0];\n    newDst[ 1] = m[ 1];\n    newDst[ 2] = m[ 2];\n    newDst[ 3] = m[ 3];\n    newDst[12] = m[12];\n    newDst[13] = m[13];\n    newDst[14] = m[14];\n    newDst[15] = m[15];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY<T extends Mat4Arg = MatType>(angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = c;  newDst[ 1] = 0;  newDst[ 2] = -s;  newDst[ 3] = 0;\n  newDst[ 4] = 0;  newDst[ 5] = 1;  newDst[ 6] =  0;  newDst[ 7] = 0;\n  newDst[ 8] = s;  newDst[ 9] = 0;  newDst[10] =  c;  newDst[11] = 0;\n  newDst[12] = 0;  newDst[13] = 0;  newDst[14] =  0;  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY<T extends Mat4Arg = MatType>(m: Mat4Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m03 = m[0 * 4 + 3];\n  const m20 = m[2 * 4 + 0];\n  const m21 = m[2 * 4 + 1];\n  const m22 = m[2 * 4 + 2];\n  const m23 = m[2 * 4 + 3];\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = c * m00 - s * m20;\n  newDst[ 1] = c * m01 - s * m21;\n  newDst[ 2] = c * m02 - s * m22;\n  newDst[ 3] = c * m03 - s * m23;\n  newDst[ 8] = c * m20 + s * m00;\n  newDst[ 9] = c * m21 + s * m01;\n  newDst[10] = c * m22 + s * m02;\n  newDst[11] = c * m23 + s * m03;\n\n  if (m !== newDst) {\n    newDst[ 4] = m[ 4];\n    newDst[ 5] = m[ 5];\n    newDst[ 6] = m[ 6];\n    newDst[ 7] = m[ 7];\n    newDst[12] = m[12];\n    newDst[13] = m[13];\n    newDst[14] = m[14];\n    newDst[15] = m[15];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ<T extends Mat4Arg = MatType>(angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] =  c;  newDst[ 1] = s;  newDst[ 2] = 0;  newDst[ 3] = 0;\n  newDst[ 4] = -s;  newDst[ 5] = c;  newDst[ 6] = 0;  newDst[ 7] = 0;\n  newDst[ 8] =  0;  newDst[ 9] = 0;  newDst[10] = 1;  newDst[11] = 0;\n  newDst[12] =  0;  newDst[13] = 0;  newDst[14] = 0;  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ<T extends Mat4Arg = MatType>(m: Mat4Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const m00 = m[0 * 4 + 0];\n  const m01 = m[0 * 4 + 1];\n  const m02 = m[0 * 4 + 2];\n  const m03 = m[0 * 4 + 3];\n  const m10 = m[1 * 4 + 0];\n  const m11 = m[1 * 4 + 1];\n  const m12 = m[1 * 4 + 2];\n  const m13 = m[1 * 4 + 3];\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n\n  newDst[ 0] = c * m00 + s * m10;\n  newDst[ 1] = c * m01 + s * m11;\n  newDst[ 2] = c * m02 + s * m12;\n  newDst[ 3] = c * m03 + s * m13;\n  newDst[ 4] = c * m10 - s * m00;\n  newDst[ 5] = c * m11 - s * m01;\n  newDst[ 6] = c * m12 - s * m02;\n  newDst[ 7] = c * m13 - s * m03;\n\n  if (m !== newDst) {\n    newDst[ 8] = m[ 8];\n    newDst[ 9] = m[ 9];\n    newDst[10] = m[10];\n    newDst[11] = m[11];\n    newDst[12] = m[12];\n    newDst[13] = m[13];\n    newDst[14] = m[14];\n    newDst[15] = m[15];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation<T extends Mat4Arg = MatType>(axis: Vec3Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  let x = axis[0];\n  let y = axis[1];\n  let z = axis[2];\n  const n = Math.sqrt(x * x + y * y + z * z);\n  x /= n;\n  y /= n;\n  z /= n;\n  const xx = x * x;\n  const yy = y * y;\n  const zz = z * z;\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n  const oneMinusCosine = 1 - c;\n\n  newDst[ 0] = xx + (1 - xx) * c;\n  newDst[ 1] = x * y * oneMinusCosine + z * s;\n  newDst[ 2] = x * z * oneMinusCosine - y * s;\n  newDst[ 3] = 0;\n  newDst[ 4] = x * y * oneMinusCosine - z * s;\n  newDst[ 5] = yy + (1 - yy) * c;\n  newDst[ 6] = y * z * oneMinusCosine + x * s;\n  newDst[ 7] = 0;\n  newDst[ 8] = x * z * oneMinusCosine + y * s;\n  newDst[ 9] = y * z * oneMinusCosine - x * s;\n  newDst[10] = zz + (1 - zz) * c;\n  newDst[11] = 0;\n  newDst[12] = 0;\n  newDst[13] = 0;\n  newDst[14] = 0;\n  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate<T extends Mat4Arg = MatType>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  let x = axis[0];\n  let y = axis[1];\n  let z = axis[2];\n  const n = Math.sqrt(x * x + y * y + z * z);\n  x /= n;\n  y /= n;\n  z /= n;\n  const xx = x * x;\n  const yy = y * y;\n  const zz = z * z;\n  const c = Math.cos(angleInRadians);\n  const s = Math.sin(angleInRadians);\n  const oneMinusCosine = 1 - c;\n\n  const r00 = xx + (1 - xx) * c;\n  const r01 = x * y * oneMinusCosine + z * s;\n  const r02 = x * z * oneMinusCosine - y * s;\n  const r10 = x * y * oneMinusCosine - z * s;\n  const r11 = yy + (1 - yy) * c;\n  const r12 = y * z * oneMinusCosine + x * s;\n  const r20 = x * z * oneMinusCosine + y * s;\n  const r21 = y * z * oneMinusCosine - x * s;\n  const r22 = zz + (1 - zz) * c;\n\n  const m00 = m[0];\n  const m01 = m[1];\n  const m02 = m[2];\n  const m03 = m[3];\n  const m10 = m[4];\n  const m11 = m[5];\n  const m12 = m[6];\n  const m13 = m[7];\n  const m20 = m[8];\n  const m21 = m[9];\n  const m22 = m[10];\n  const m23 = m[11];\n\n  newDst[ 0] = r00 * m00 + r01 * m10 + r02 * m20;\n  newDst[ 1] = r00 * m01 + r01 * m11 + r02 * m21;\n  newDst[ 2] = r00 * m02 + r01 * m12 + r02 * m22;\n  newDst[ 3] = r00 * m03 + r01 * m13 + r02 * m23;\n  newDst[ 4] = r10 * m00 + r11 * m10 + r12 * m20;\n  newDst[ 5] = r10 * m01 + r11 * m11 + r12 * m21;\n  newDst[ 6] = r10 * m02 + r11 * m12 + r12 * m22;\n  newDst[ 7] = r10 * m03 + r11 * m13 + r12 * m23;\n  newDst[ 8] = r20 * m00 + r21 * m10 + r22 * m20;\n  newDst[ 9] = r20 * m01 + r21 * m11 + r22 * m21;\n  newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n  newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n\n  if (m !== newDst) {\n    newDst[12] = m[12];\n    newDst[13] = m[13];\n    newDst[14] = m[14];\n    newDst[15] = m[15];\n  }\n\n  return newDst;\n}\n\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling<T extends Mat4Arg = MatType>(v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = v[0];  newDst[ 1] = 0;     newDst[ 2] = 0;     newDst[ 3] = 0;\n  newDst[ 4] = 0;     newDst[ 5] = v[1];  newDst[ 6] = 0;     newDst[ 7] = 0;\n  newDst[ 8] = 0;     newDst[ 9] = 0;     newDst[10] = v[2];  newDst[11] = 0;\n  newDst[12] = 0;     newDst[13] = 0;     newDst[14] = 0;     newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale<T extends Mat4Arg = MatType>(m: Mat4Arg, v: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n\n  newDst[ 0] = v0 * m[0 * 4 + 0];\n  newDst[ 1] = v0 * m[0 * 4 + 1];\n  newDst[ 2] = v0 * m[0 * 4 + 2];\n  newDst[ 3] = v0 * m[0 * 4 + 3];\n  newDst[ 4] = v1 * m[1 * 4 + 0];\n  newDst[ 5] = v1 * m[1 * 4 + 1];\n  newDst[ 6] = v1 * m[1 * 4 + 2];\n  newDst[ 7] = v1 * m[1 * 4 + 3];\n  newDst[ 8] = v2 * m[2 * 4 + 0];\n  newDst[ 9] = v2 * m[2 * 4 + 1];\n  newDst[10] = v2 * m[2 * 4 + 2];\n  newDst[11] = v2 * m[2 * 4 + 3];\n\n  if (m !== newDst) {\n    newDst[12] = m[12];\n    newDst[13] = m[13];\n    newDst[14] = m[14];\n    newDst[15] = m[15];\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n * @param s - the amount to scale\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction uniformScaling<T extends Mat4Arg = MatType>(s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = s;  newDst[ 1] = 0;  newDst[ 2] = 0;  newDst[ 3] = 0;\n  newDst[ 4] = 0;  newDst[ 5] = s;  newDst[ 6] = 0;  newDst[ 7] = 0;\n  newDst[ 8] = 0;  newDst[ 9] = 0;  newDst[10] = s;  newDst[11] = 0;\n  newDst[12] = 0;  newDst[13] = 0;  newDst[14] = 0;  newDst[15] = 1;\n\n  return newDst;\n}\n\n/**\n * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n * @param m - The matrix to be modified.\n * @param s - The amount to scale.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction uniformScale<T extends Mat4Arg = MatType>(m: Mat4Arg, s: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(16)) as T;\n\n  newDst[ 0] = s * m[0 * 4 + 0];\n  newDst[ 1] = s * m[0 * 4 + 1];\n  newDst[ 2] = s * m[0 * 4 + 2];\n  newDst[ 3] = s * m[0 * 4 + 3];\n  newDst[ 4] = s * m[1 * 4 + 0];\n  newDst[ 5] = s * m[1 * 4 + 1];\n  newDst[ 6] = s * m[1 * 4 + 2];\n  newDst[ 7] = s * m[1 * 4 + 3];\n  newDst[ 8] = s * m[2 * 4 + 0];\n  newDst[ 9] = s * m[2 * 4 + 1];\n  newDst[10] = s * m[2 * 4 + 2];\n  newDst[11] = s * m[2 * 4 + 3];\n\n  if (m !== newDst) {\n    newDst[12] = m[12];\n    newDst[13] = m[13];\n    newDst[14] = m[14];\n    newDst[15] = m[15];\n  }\n\n  return newDst;\n}\n\nreturn {\n  add,\n  aim,\n  axisRotate,\n  axisRotation,\n  cameraAim,\n  clone,\n  copy,\n  create,\n  determinant,\n  equals,\n  equalsApproximately,\n  fromMat3,\n  fromQuat,\n  frustum,\n  frustumReverseZ,\n  getAxis,\n  getScaling,\n  getTranslation,\n  identity,\n  inverse,\n  invert,\n  lookAt,\n  mul,\n  mulScalar,\n  multiply,\n  multiplyScalar,\n  negate,\n  ortho,\n  perspective,\n  perspectiveReverseZ,\n  rotate,\n  rotateX,\n  rotateY,\n  rotateZ,\n  rotation,\n  rotationX,\n  rotationY,\n  rotationZ,\n  scale,\n  scaling,\n  set,\n  setAxis,\n  setTranslation,\n  translate,\n  translation,\n  transpose,\n  uniformScale,\n  uniformScaling,\n};\n\n}\n\n\ntype API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;\n\nconst cache = new Map();\n\nexport function getAPI<T extends Mat4Arg = Float32Array>(Ctor: Mat4Ctor<T>) {\n  let api = cache.get(Ctor);\n  if (!api) {\n    api = getAPIImpl<T>(Ctor);\n    cache.set(Ctor, api);\n  }\n  return api as API<T>;\n}\n", "/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport * as utils from './utils.js';\nimport { QuatArg, QuatType } from './quat';\nimport { Mat3Arg } from './mat3.js';\nimport { Mat4Arg } from './mat4.js';\nimport { Vec3Arg } from './vec3.js';\nimport { getAPI as getVec3API } from './vec3-impl';\nimport { BaseArgType } from './types';\n\nexport { QuatArg, QuatType };\n\ntype QuatCtor<T extends QuatArg = Float32Array>  = new (n: number) => T;\n\nexport type RotationOrder =  'xyz' |  'xzy' |  'yxz' |  'yzx' |  'zxy' |  'zyx';\n\n/**\n * Generates am typed API for Qud\n * */\nfunction getAPIImpl<QuatType extends QuatArg = Float32Array>(Ctor: QuatCtor<QuatType>) {\n  const vec3 = getVec3API<QuatType>(Ctor);\n\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x?: number, y?: number, z?: number, w?: number) {\n  const newDst = new Ctor(4);\n  if (x !== undefined) {\n    newDst[0] = x;\n    if (y !== undefined) {\n      newDst[1] = y;\n      if (z !== undefined) {\n        newDst[2] = z;\n        if (w !== undefined) {\n          newDst[3] = w;\n        }\n      }\n    }\n  }\n  return newDst;\n}\n\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n\n/**\n * Sets the values of a Quat\n * Also see {@link quat.create} and {@link quat.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set<T extends QuatArg = QuatType>(x: number, y: number, z: number, w: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = x;\n  newDst[1] = y;\n  newDst[2] = z;\n  newDst[3] = w;\n\n  return newDst;\n}\n\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle<T extends QuatArg = QuatType>(axis: Vec3Arg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const halfAngle = angleInRadians * 0.5;\n  const s = Math.sin(halfAngle);\n\n  newDst[0] = s * axis[0];\n  newDst[1] = s * axis[1];\n  newDst[2] = s * axis[2];\n  newDst[3] = Math.cos(halfAngle);\n\n  return newDst;\n}\n\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle<T extends Vec3Arg = QuatType>(q: QuatArg, dst?: T): { angle: number, axis: T } {\n  const newDst = (dst ?? vec3.create(3)) as T;\n\n  const angle = Math.acos(q[3]) * 2;\n  const s = Math.sin(angle * 0.5);\n  if (s > utils.EPSILON) {\n    newDst[0] = q[0] / s;\n    newDst[1] = q[1] / s;\n    newDst[2] = q[2] / s;\n  } else {\n    newDst[0] = 1;\n    newDst[1] = 0;\n    newDst[2] = 0;\n  }\n\n  return { angle, axis: newDst };\n}\n\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a: QuatArg, b: QuatArg) {\n  const d = dot(a, b);\n  return Math.acos(2 * d * d - 1);\n}\n\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply<T extends QuatArg = QuatType>(a: QuatArg, b: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const ax = a[0];\n  const ay = a[1];\n  const az = a[2];\n  const aw = a[3];\n\n  const bx = b[0];\n  const by = b[1];\n  const bz = b[2];\n  const bw = b[3];\n\n  newDst[0] = ax * bw + aw * bx + ay * bz - az * by;\n  newDst[1] = ay * bw + aw * by + az * bx - ax * bz;\n  newDst[2] = az * bw + aw * bz + ax * by - ay * bx;\n  newDst[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n  return newDst;\n}\n\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul = multiply;\n\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX<T extends QuatArg = QuatType>(q: QuatArg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const halfAngle = angleInRadians * 0.5;\n\n  const qx = q[0];\n  const qy = q[1];\n  const qz = q[2];\n  const qw = q[3];\n\n  const bx = Math.sin(halfAngle);\n  const bw = Math.cos(halfAngle);\n\n  newDst[0] = qx * bw + qw * bx;\n  newDst[1] = qy * bw + qz * bx;\n  newDst[2] = qz * bw - qy * bx;\n  newDst[3] = qw * bw - qx * bx;\n\n  return newDst;\n}\n\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY<T extends QuatArg = QuatType>(q: QuatArg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const halfAngle = angleInRadians * 0.5;\n\n  const qx = q[0];\n  const qy = q[1];\n  const qz = q[2];\n  const qw = q[3];\n\n  const by = Math.sin(halfAngle);\n  const bw = Math.cos(halfAngle);\n\n  newDst[0] = qx * bw - qz * by;\n  newDst[1] = qy * bw + qw * by;\n  newDst[2] = qz * bw + qx * by;\n  newDst[3] = qw * bw - qy * by;\n\n  return newDst;\n}\n\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ<T extends QuatArg = QuatType>(q: QuatArg, angleInRadians: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const halfAngle = angleInRadians * 0.5;\n\n  const qx = q[0];\n  const qy = q[1];\n  const qz = q[2];\n  const qw = q[3];\n\n  const bz = Math.sin(halfAngle);\n  const bw = Math.cos(halfAngle);\n\n  newDst[0] = qx * bw + qy * bz;\n  newDst[1] = qy * bw - qx * bz;\n  newDst[2] = qz * bw + qw * bz;\n  newDst[3] = qw * bw - qz * bz;\n\n  return newDst;\n}\n\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp<T extends QuatArg = QuatType>(a: QuatArg, b: QuatArg, t: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const ax = a[0];\n  const ay = a[1];\n  const az = a[2];\n  const aw = a[3];\n\n  let bx = b[0];\n  let by = b[1];\n  let bz = b[2];\n  let bw = b[3];\n\n  let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n\n  if (cosOmega < 0) {\n    cosOmega = -cosOmega;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n\n  let scale0;\n  let scale1;\n\n  if (1.0 - cosOmega > utils.EPSILON) {\n    const omega = Math.acos(cosOmega);\n    const sinOmega = Math.sin(omega);\n    scale0 = Math.sin((1 - t) * omega) / sinOmega;\n    scale1 = Math.sin(t * omega) / sinOmega;\n  } else {\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n\n  newDst[0] = scale0 * ax + scale1 * bx;\n  newDst[1] = scale0 * ay + scale1 * by;\n  newDst[2] = scale0 * az + scale1 * bz;\n  newDst[3] = scale0 * aw + scale1 * bw;\n\n  return newDst;\n}\n\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse<T extends QuatArg = QuatType>(q: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const a0 = q[0];\n  const a1 = q[1];\n  const a2 = q[2];\n  const a3 = q[3];\n\n  const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  const invDot = dot ? 1 / dot : 0;\n\n  newDst[0] = -a0 * invDot;\n  newDst[1] = -a1 * invDot;\n  newDst[2] = -a2 * invDot;\n  newDst[3] =  a3 * invDot;\n\n  return newDst;\n}\n\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate<T extends QuatArg = QuatType>(q: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = -q[0];\n  newDst[1] = -q[1];\n  newDst[2] = -q[2];\n  newDst[3] =  q[3];\n\n  return newDst;\n}\n\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat<T extends QuatArg = QuatType>(m: Mat3Arg | Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  /*\n  0 1 2\n  3 4 5\n  6 7 8\n\n  0 1 2\n  4 5 6\n  8 9 10\n   */\n\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  const trace = m[0] + m[5] + m[10];\n\n  if (trace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    const root = Math.sqrt(trace + 1); // 2w\n    newDst[3] = 0.5 * root;\n    const invRoot = 0.5 / root; // 1/(4w)\n\n    newDst[0] = (m[6] - m[9]) * invRoot;\n    newDst[1] = (m[8] - m[2]) * invRoot;\n    newDst[2] = (m[1] - m[4]) * invRoot;\n  } else {\n    // |w| <= 1/2\n    let i = 0;\n\n    if (m[5] > m[0]) {\n      i = 1;\n    }\n    if (m[10] > m[i * 4 + i]) {\n      i = 2;\n    }\n\n    const j = (i + 1) % 3;\n    const k = (i + 2) % 3;\n\n    const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n    newDst[i] = 0.5 * root;\n\n    const invRoot = 0.5 / root;\n\n    newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n    newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n    newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n  }\n\n  return newDst;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler<T extends QuatArg = QuatType>(\n    xAngleInRadians: number,\n    yAngleInRadians: number,\n    zAngleInRadians: number,\n    order: RotationOrder,\n    dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const xHalfAngle = xAngleInRadians * 0.5;\n  const yHalfAngle = yAngleInRadians * 0.5;\n  const zHalfAngle = zAngleInRadians * 0.5;\n\n  const sx = Math.sin(xHalfAngle);\n  const cx = Math.cos(xHalfAngle);\n  const sy = Math.sin(yHalfAngle);\n  const cy = Math.cos(yHalfAngle);\n  const sz = Math.sin(zHalfAngle);\n  const cz = Math.cos(zHalfAngle);\n\n  switch (order) {\n    case 'xyz':\n      newDst[0] = sx * cy * cz + cx * sy * sz;\n      newDst[1] = cx * sy * cz - sx * cy * sz;\n      newDst[2] = cx * cy * sz + sx * sy * cz;\n      newDst[3] = cx * cy * cz - sx * sy * sz;\n      break;\n\n    case 'xzy':\n      newDst[0] = sx * cy * cz - cx * sy * sz;\n      newDst[1] = cx * sy * cz - sx * cy * sz;\n      newDst[2] = cx * cy * sz + sx * sy * cz;\n      newDst[3] = cx * cy * cz + sx * sy * sz;\n      break;\n\n    case 'yxz':\n      newDst[0] = sx * cy * cz + cx * sy * sz;\n      newDst[1] = cx * sy * cz - sx * cy * sz;\n      newDst[2] = cx * cy * sz - sx * sy * cz;\n      newDst[3] = cx * cy * cz + sx * sy * sz;\n      break;\n\n    case 'yzx':\n      newDst[0] = sx * cy * cz + cx * sy * sz;\n      newDst[1] = cx * sy * cz + sx * cy * sz;\n      newDst[2] = cx * cy * sz - sx * sy * cz;\n      newDst[3] = cx * cy * cz - sx * sy * sz;\n      break;\n\n    case 'zxy':\n      newDst[0] = sx * cy * cz - cx * sy * sz;\n      newDst[1] = cx * sy * cz + sx * cy * sz;\n      newDst[2] = cx * cy * sz + sx * sy * cz;\n      newDst[3] = cx * cy * cz - sx * sy * sz;\n      break;\n\n    case 'zyx':\n      newDst[0] = sx * cy * cz - cx * sy * sz;\n      newDst[1] = cx * sy * cz + sx * cy * sz;\n      newDst[2] = cx * cy * sz - sx * sy * cz;\n      newDst[3] = cx * cy * cz + sx * sy * sz;\n      break;\n\n    default:\n      throw new Error(`Unknown rotation order: ${order}`);\n  }\n\n  return newDst;\n}\n\n/**\n * Copies a quaternion. (same as {@link quat.clone})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy<T extends QuatArg = QuatType>(q: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = q[0];\n  newDst[1] = q[1];\n  newDst[2] = q[2];\n  newDst[3] = q[3];\n\n  return newDst;\n}\n\n/**\n * Clones a quaternion. (same as {@link quat.copy})\n * Also see {@link quat.create} and {@link quat.set}\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone = copy;\n\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add<T extends QuatArg = QuatType>(a: QuatArg, b: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] + b[0];\n  newDst[1] = a[1] + b[1];\n  newDst[2] = a[2] + b[2];\n  newDst[3] = a[3] + b[3];\n\n  return newDst;\n}\n\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract<T extends QuatArg = QuatType>(a: QuatArg, b: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] - b[0];\n  newDst[1] = a[1] - b[1];\n  newDst[2] = a[2] - b[2];\n  newDst[3] = a[3] - b[3];\n\n  return newDst;\n}\n\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub = subtract;\n\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar<T extends QuatArg = QuatType>(v: QuatArg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = v[0] * k;\n  newDst[1] = v[1] * k;\n  newDst[2] = v[2] * k;\n  newDst[3] = v[3] * k;\n\n  return newDst;\n}\n\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale = mulScalar;\n\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar<T extends QuatArg = QuatType>(v: QuatArg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = v[0] / k;\n  newDst[1] = v[1] / k;\n  newDst[2] = v[2] / k;\n  newDst[3] = v[3] / k;\n\n  return newDst;\n}\n\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot(a: QuatArg, b: QuatArg): number {\n  return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp<T extends QuatArg = QuatType>(a: QuatArg, b: QuatArg, t: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] + t * (b[0] - a[0]);\n  newDst[1] = a[1] + t * (b[1] - a[1]);\n  newDst[2] = a[2] + t * (b[2] - a[2]);\n  newDst[3] = a[3] + t * (b[3] - a[3]);\n\n  return newDst;\n}\n\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length(v: QuatArg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const v3 = v[3];\n  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len = length;\n\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq(v: QuatArg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const v3 = v[3];\n  return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq = lengthSq;\n\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize<T extends QuatArg = QuatType>(v: QuatArg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const v3 = v[3];\n  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n\n  if (len > 0.00001) {\n    newDst[0] = v0 / len;\n    newDst[1] = v1 / len;\n    newDst[2] = v2 / len;\n    newDst[3] = v3 / len;\n  } else {\n    newDst[0] = 0;\n    newDst[1] = 0;\n    newDst[2] = 0;\n    newDst[3] = 1;\n  }\n\n  return newDst;\n}\n\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately(a: QuatArg, b: QuatArg): boolean {\n  return Math.abs(a[0] - b[0]) < utils.EPSILON &&\n         Math.abs(a[1] - b[1]) < utils.EPSILON &&\n         Math.abs(a[2] - b[2]) < utils.EPSILON &&\n         Math.abs(a[3] - b[3]) < utils.EPSILON;\n}\n\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals(a: QuatArg, b: QuatArg): boolean {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity<T extends QuatArg = QuatType>(dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = 0;\n  newDst[1] = 0;\n  newDst[2] = 0;\n  newDst[3] = 1;\n\n  return newDst;\n}\n\nconst tempVec3 = vec3.create();\nconst xUnitVec3 = vec3.create();\nconst yUnitVec3 = vec3.create();\n\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo<T extends QuatArg = QuatType>(aUnit: Vec3Arg, bUnit: Vec3Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const dot = vec3.dot(aUnit, bUnit);\n  if (dot < -0.999999) {\n    vec3.cross(xUnitVec3, aUnit, tempVec3);\n    if (vec3.len(tempVec3) < 0.000001) {\n      vec3.cross(yUnitVec3, aUnit, tempVec3);\n    }\n\n    vec3.normalize(tempVec3, tempVec3);\n    fromAxisAngle(tempVec3, Math.PI, newDst);\n\n    return newDst;\n  } else if (dot > 0.999999) {\n    newDst[0] = 0;\n    newDst[1] = 0;\n    newDst[2] = 0;\n    newDst[3] = 1;\n\n    return newDst;\n  } else {\n    vec3.cross(aUnit, bUnit, tempVec3);\n\n    newDst[0] = tempVec3[0];\n    newDst[1] = tempVec3[1];\n    newDst[2] = tempVec3[2];\n    newDst[3] = 1 + dot;\n\n    return normalize(newDst, newDst);\n  }\n}\n\nconst tempQuat1 = new Ctor(4);\nconst tempQuat2 = new Ctor(4);\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp<T extends QuatArg = QuatType>(\n    a: QuatArg,\n    b: QuatArg,\n    c: QuatArg,\n    d: QuatArg,\n    t: number,\n    dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  slerp(a, d, t, tempQuat1);\n  slerp(b, c, t, tempQuat2);\n  slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);\n\n  return newDst;\n}\n\nreturn {\n  create,\n  fromValues,\n  set,\n  fromAxisAngle,\n  toAxisAngle,\n  angle,\n  multiply,\n  mul,\n  rotateX,\n  rotateY,\n  rotateZ,\n  slerp,\n  inverse,\n  conjugate,\n  fromMat,\n  fromEuler,\n  copy,\n  clone,\n  add,\n  subtract,\n  sub,\n  mulScalar,\n  scale,\n  divScalar,\n  dot,\n  lerp,\n  length,\n  len,\n  lengthSq,\n  lenSq,\n  normalize,\n  equalsApproximately,\n  equals,\n  identity,\n  rotationTo,\n  sqlerp,\n};\n\n}\n\ntype API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;\n\nconst cache = new Map();\n\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nexport function getAPI<T extends QuatArg = Float32Array>(Ctor: QuatCtor<T>) {\n  let api = cache.get(Ctor);\n  if (!api) {\n    api = getAPIImpl<T>(Ctor);\n    cache.set(Ctor, api);\n  }\n  return api as API<T>;\n}\n", "/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport * as utils from './utils.js';\nimport { Vec4Arg, Vec4Type } from './vec4';\nimport { Mat4Arg } from './mat4';\nimport { BaseArgType } from './types';\n\nexport { Vec4Arg, Vec4Type };\n\ntype Vec4Ctor<T extends Vec4Arg = Float32Array>  = new (n: number) => T;\n\n/**\n * Generates am typed API for Vec4\n * */\nfunction getAPIImpl<VecType extends Vec4Arg = Float32Array>(Ctor: Vec4Ctor<VecType>) {\n\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x?: number, y?: number, z?: number, w?: number) {\n  const newDst = new Ctor(4);\n  if (x !== undefined) {\n    newDst[0] = x;\n    if (y !== undefined) {\n      newDst[1] = y;\n      if (z !== undefined) {\n        newDst[2] = z;\n        if (w !== undefined) {\n          newDst[3] = w;\n        }\n      }\n    }\n  }\n  return newDst;\n}\n\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n\n/**\n * Sets the values of a Vec4\n * Also see {@link vec4.create} and {@link vec4.copy}\n *\n * @param x first value\n * @param y second value\n * @param z third value\n * @param w fourth value\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector with its elements set.\n */\nfunction set<T extends Vec4Arg = VecType>(x: number, y: number, z: number, w: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = x;\n  newDst[1] = y;\n  newDst[2] = z;\n  newDst[3] = w;\n\n  return newDst;\n}\n\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = Math.ceil(v[0]);\n  newDst[1] = Math.ceil(v[1]);\n  newDst[2] = Math.ceil(v[2]);\n  newDst[3] = Math.ceil(v[3]);\n\n  return newDst;\n}\n\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = Math.floor(v[0]);\n  newDst[1] = Math.floor(v[1]);\n  newDst[2] = Math.floor(v[2]);\n  newDst[3] = Math.floor(v[3]);\n\n  return newDst;\n}\n\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = Math.round(v[0]);\n  newDst[1] = Math.round(v[1]);\n  newDst[2] = Math.round(v[2]);\n  newDst[3] = Math.round(v[3]);\n\n  return newDst;\n}\n\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp<T extends Vec4Arg = VecType>(v: Vec4Arg, min = 0, max = 1, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = Math.min(max, Math.max(min, v[0]));\n  newDst[1] = Math.min(max, Math.max(min, v[1]));\n  newDst[2] = Math.min(max, Math.max(min, v[2]));\n  newDst[3] = Math.min(max, Math.max(min, v[3]));\n\n  return newDst;\n}\n\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] + b[0];\n  newDst[1] = a[1] + b[1];\n  newDst[2] = a[2] + b[2];\n  newDst[3] = a[3] + b[3];\n\n  return newDst;\n}\n\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, scale: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] + b[0] * scale;\n  newDst[1] = a[1] + b[1] * scale;\n  newDst[2] = a[2] + b[2] * scale;\n  newDst[3] = a[3] + b[3] * scale;\n\n  return newDst;\n}\n\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] - b[0];\n  newDst[1] = a[1] - b[1];\n  newDst[2] = a[2] - b[2];\n  newDst[3] = a[3] - b[3];\n\n  return newDst;\n}\n\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a: Vec4Arg, b: Vec4Arg): boolean {\n  return Math.abs(a[0] - b[0]) < utils.EPSILON &&\n         Math.abs(a[1] - b[1]) < utils.EPSILON &&\n         Math.abs(a[2] - b[2]) < utils.EPSILON &&\n         Math.abs(a[3] - b[3]) < utils.EPSILON;\n}\n\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a: Vec4Arg, b: Vec4Arg): boolean {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, t: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] + t * (b[0] - a[0]);\n  newDst[1] = a[1] + t * (b[1] - a[1]);\n  newDst[2] = a[2] + t * (b[2] - a[2]);\n  newDst[3] = a[3] + t * (b[3] - a[3]);\n\n  return newDst;\n}\n\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, t: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n  newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n  newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n  newDst[3] = a[3] + t[3] * (b[3] - a[3]);\n\n  return newDst;\n}\n\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = Math.max(a[0], b[0]);\n  newDst[1] = Math.max(a[1], b[1]);\n  newDst[2] = Math.max(a[2], b[2]);\n  newDst[3] = Math.max(a[3], b[3]);\n\n  return newDst;\n}\n\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = Math.min(a[0], b[0]);\n  newDst[1] = Math.min(a[1], b[1]);\n  newDst[2] = Math.min(a[2], b[2]);\n  newDst[3] = Math.min(a[3], b[3]);\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar<T extends Vec4Arg = VecType>(v: Vec4Arg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = v[0] * k;\n  newDst[1] = v[1] * k;\n  newDst[2] = v[2] * k;\n  newDst[3] = v[3] * k;\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar<T extends Vec4Arg = VecType>(v: Vec4Arg, k: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = v[0] / k;\n  newDst[1] = v[1] / k;\n  newDst[2] = v[2] / k;\n  newDst[3] = v[3] / k;\n\n  return newDst;\n}\n\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = 1 / v[0];\n  newDst[1] = 1 / v[1];\n  newDst[2] = 1 / v[2];\n  newDst[3] = 1 / v[3];\n\n  return newDst;\n}\n\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a: Vec4Arg, b: Vec4Arg): number {\n  return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v: Vec4Arg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const v3 = v[3];\n  return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v: Vec4Arg): number {\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const v3 = v[3];\n  return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a: Vec4Arg, b: Vec4Arg): number {\n  const dx = a[0] - b[0];\n  const dy = a[1] - b[1];\n  const dz = a[2] - b[2];\n  const dw = a[3] - b[3];\n  return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a: Vec4Arg, b: Vec4Arg): number {\n  const dx = a[0] - b[0];\n  const dy = a[1] - b[1];\n  const dz = a[2] - b[2];\n  const dw = a[3] - b[3];\n  return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const v0 = v[0];\n  const v1 = v[1];\n  const v2 = v[2];\n  const v3 = v[3];\n  const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n\n  if (len > 0.00001) {\n    newDst[0] = v0 / len;\n    newDst[1] = v1 / len;\n    newDst[2] = v2 / len;\n    newDst[3] = v3 / len;\n  } else {\n    newDst[0] = 0;\n    newDst[1] = 0;\n    newDst[2] = 0;\n    newDst[3] = 0;\n  }\n\n  return newDst;\n}\n\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = -v[0];\n  newDst[1] = -v[1];\n  newDst[2] = -v[2];\n  newDst[3] = -v[3];\n\n  return newDst;\n}\n\n/**\n * Copies a vector. (same as {@link vec4.clone})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy<T extends Vec4Arg = VecType>(v: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = v[0];\n  newDst[1] = v[1];\n  newDst[2] = v[2];\n  newDst[3] = v[3];\n\n  return newDst;\n}\n\n/**\n * Clones a vector. (same as {@link vec4.copy})\n * Also see {@link vec4.create} and {@link vec4.set}\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] * b[0];\n  newDst[1] = a[1] * b[1];\n  newDst[2] = a[2] * b[2];\n  newDst[3] = a[3] * b[3];\n\n  return newDst;\n}\n\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = a[0] / b[0];\n  newDst[1] = a[1] / b[1];\n  newDst[2] = a[2] / b[2];\n  newDst[3] = a[3] / b[3];\n\n  return newDst;\n}\n\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero<T extends Vec4Arg = VecType>(dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  newDst[0] = 0;\n  newDst[1] = 0;\n  newDst[2] = 0;\n  newDst[3] = 0;\n\n  return newDst;\n}\n\n\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4<T extends Vec4Arg = VecType>(v: Vec4Arg, m: Mat4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  const x = v[0];\n  const y = v[1];\n  const z = v[2];\n  const w = v[3];\n\n  newDst[0] = m[0] * x + m[4] * y + m[ 8] * z + m[12] * w;\n  newDst[1] = m[1] * x + m[5] * y + m[ 9] * z + m[13] * w;\n  newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n\n  return newDst;\n}\n\n\n/**\n * Treat a 4D vector as a direction and set it's length\n *\n * @param a The vec4 to lengthen\n * @param len The length of the resulting vector\n * @returns The lengthened vector\n */\nfunction setLength<T extends Vec4Arg = VecType>(a: Vec4Arg, len: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n  normalize(a, newDst);\n  return mulScalar(newDst, len, newDst);\n}\n\n/**\n * Ensure a vector is not longer than a max length\n *\n * @param a The vec4 to limit\n * @param maxLen The longest length of the resulting vector\n * @returns The vector, shortened to maxLen if it's too long\n */\nfunction truncate<T extends Vec4Arg = VecType>(a: Vec4Arg, maxLen: number, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n\n  if (length(a) > maxLen) {\n    return setLength(a, maxLen, newDst);\n  }\n\n  return copy(a, newDst);\n}\n\n/**\n * Return the vector exactly between 2 endpoint vectors\n *\n * @param a Endpoint 1\n * @param b Endpoint 2\n * @returns The vector exactly residing between endpoints 1 and 2\n */\nfunction midpoint<T extends Vec4Arg = VecType>(a: Vec4Arg, b: Vec4Arg, dst?: T) {\n  const newDst = (dst ?? new Ctor(4)) as T;\n  return lerp(a, b, 0.5, newDst);\n}\n\nreturn {\n  create,\n  fromValues,\n  set,\n  ceil,\n  floor,\n  round,\n  clamp,\n  add,\n  addScaled,\n  subtract,\n  sub,\n  equalsApproximately,\n  equals,\n  lerp,\n  lerpV,\n  max,\n  min,\n  mulScalar,\n  scale,\n  divScalar,\n  inverse,\n  invert,\n  dot,\n  length,\n  len,\n  lengthSq,\n  lenSq,\n  distance,\n  dist,\n  distanceSq,\n  distSq,\n  normalize,\n  negate,\n  copy,\n  clone,\n  multiply,\n  mul,\n  divide,\n  div,\n  zero,\n  transformMat4,\n  setLength,\n  truncate,\n  midpoint,\n};\n}\n\ntype API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;\n\nconst cache = new Map();\n\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nexport function getAPI<T extends Mat4Arg = Float32Array>(Ctor: Vec4Ctor<T>) {\n  let api = cache.get(Ctor);\n  if (!api) {\n    api = getAPIImpl<T>(Ctor);\n    cache.set(Ctor, api);\n  }\n  return api as API<T>;\n}\n\n", "/**\n * Some docs\n * @namespace wgpu-matrix\n */\nimport {MutableNumberArray, BaseArgType, ZeroArray} from './types';\nimport {Mat3Arg, Mat3Type, getAPI as getMat3API} from './mat3-impl';\nimport {Mat4Arg, Mat4Type, getAPI as getMat4API} from './mat4-impl';\nimport {QuatArg, QuatType, getAPI as getQuatAPI, RotationOrder} from './quat-impl';\nimport {Vec2Arg, Vec2Type, getAPI as getVec2API} from './vec2-impl';\nimport {Vec3Arg, Vec3Type, getAPI as getVec3API} from './vec3-impl';\nimport {Vec4Arg, Vec4Type, getAPI as getVec4API} from './vec4-impl';\nimport * as utils from './utils';\n\nexport {\n  RotationOrder,\n  utils,\n\n  MutableNumberArray,\n  BaseArgType,\n\n  Mat3Arg,\n  Mat4Arg,\n  QuatArg,\n  Vec2Arg,\n  Vec3Arg,\n  Vec4Arg,\n\n  Mat3Type,\n  Mat4Type,\n  QuatType,\n  Vec2Type,\n  Vec3Type,\n  Vec4Type,\n};\n\nexport type BaseCtor<T extends BaseArgType>  = new (n: number) => T;\n\nexport type Mat3 = Mat3Type<Float32Array>;\nexport type Mat4 = Mat4Type<Float32Array>;\nexport type Quat = QuatType<Float32Array>;\nexport type Vec2 = Vec2Type<Float32Array>;\nexport type Vec3 = Vec3Type<Float32Array>;\nexport type Vec4 = Vec4Type<Float32Array>;\n\nexport type Mat3d = Mat3Type<Float64Array>;\nexport type Mat4d = Mat4Type<Float64Array>;\nexport type Quatd = QuatType<Float64Array>;\nexport type Vec2d = Vec2Type<Float64Array>;\nexport type Vec3d = Vec3Type<Float64Array>;\nexport type Vec4d = Vec4Type<Float64Array>;\n\nexport type Mat3n = Mat3Type<number[]>;\nexport type Mat4n = Mat4Type<number[]>;\nexport type Quatn = QuatType<number[]>;\nexport type Vec2n = Vec2Type<number[]>;\nexport type Vec3n = Vec3Type<number[]>;\nexport type Vec4n = Vec4Type<number[]>;\n\n/**\n * Generate wgpu-matrix API for type\n */\nfunction wgpuMatrixAPI<\n    Mat3 extends BaseArgType,\n    Mat4 extends BaseArgType,\n    Quat extends BaseArgType,\n    Vec2 extends BaseArgType,\n    Vec3 extends BaseArgType,\n    Vec4 extends BaseArgType,\n>(\n    Mat3Ctor: BaseCtor<Mat3>,\n    Mat4Ctor: BaseCtor<Mat4>,\n    QuatCtor: BaseCtor<Quat>,\n    Vec2Ctor: BaseCtor<Vec2>,\n    Vec3Ctor: BaseCtor<Vec3>,\n    Vec4Ctor: BaseCtor<Vec4>,\n) {\n  return {\n    /** @namespace mat3 */\n    mat3: getMat3API<Mat3>(Mat3Ctor),\n    /** @namespace mat4 */\n    mat4: getMat4API<Mat4>(Mat4Ctor),\n    /** @namespace quat */\n    quat: getQuatAPI<Quat>(QuatCtor),\n    /** @namespace vec2 */\n    vec2: getVec2API<Vec2>(Vec2Ctor),\n    /** @namespace vec3 */\n    vec3: getVec3API<Vec3>(Vec3Ctor),\n    /** @namespace vec4 */\n    vec4: getVec4API<Vec4>(Vec4Ctor),\n  };\n}\n\nexport const {\n  /**\n   * 3x3 Matrix functions that default to returning `Float32Array`\n   * @namespace\n   */\n  mat3,\n  /**\n   * 4x4 Matrix functions that default to returning `Float32Array`\n   * @namespace\n   */\n  mat4,\n  /**\n   * Quaternion functions that default to returning `Float32Array`\n   * @namespace\n   */\n  quat,\n  /**\n   * Vec2 functions that default to returning `Float32Array`\n   * @namespace\n   */\n  vec2,\n  /**\n   * Vec3 functions that default to returning `Float32Array`\n   * @namespace\n   */\n  vec3,\n  /**\n   * Vec3 functions that default to returning `Float32Array`\n   * @namespace\n   */\n  vec4,\n} = wgpuMatrixAPI<\n  Mat3, Mat4, Quat, Vec2, Vec3, Vec4>(\n    Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array);\n\nexport const {\n  /**\n   * 3x3 Matrix functions that default to returning `Float64Array`\n   * @namespace\n   */\n  mat3: mat3d,\n  /**\n   * 4x4 Matrix functions that default to returning `Float64Array`\n   * @namespace\n   */\n  mat4: mat4d,\n  /**\n   * Quaternion functions that default to returning `Float64Array`\n   * @namespace\n   */\n  quat: quatd,\n  /**\n   * Vec2 functions that default to returning `Float64Array`\n   * @namespace\n   */\n  vec2: vec2d,\n  /**\n   * Vec3 functions that default to returning `Float64Array`\n   * @namespace\n   */\n  vec3: vec3d,\n  /**\n   * Vec3 functions that default to returning `Float64Array`\n   * @namespace\n   */\n  vec4: vec4d,\n} = wgpuMatrixAPI<\n  Mat3d, Mat4d, Quatd, Vec2d, Vec3d, Vec4d>(\n    Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array);\n\nexport const {\n  /**\n   * 3x3 Matrix functions that default to returning `number[]`\n   * @namespace\n   */\n  mat3: mat3n,\n  /**\n   * 4x4 Matrix functions that default to returning `number[]`\n   * @namespace\n   */\n  mat4: mat4n,\n  /**\n   * Quaternion functions that default to returning `number[]`\n   * @namespace\n   */\n  quat: quatn,\n  /**\n   * Vec2 functions that default to returning `number[]`\n   * @namespace\n   */\n  vec2: vec2n,\n  /**\n   * Vec3 functions that default to returning `number[]`\n   * @namespace\n   */\n  vec3: vec3n,\n  /**\n   * Vec3 functions that default to returning `number[]`\n   * @namespace\n   */\n  vec4: vec4n,\n} = wgpuMatrixAPI<\n  Mat3n, Mat4n, Quatn, Vec2n, Vec3n, Vec4n>(\n    ZeroArray, Array, Array, Array, Array, Array);\n", "import { vec3, type Vec3 } from \"wgpu-matrix\"\r\n\r\nconst workgroupSize = 64; // number of threads per compute workgroup\r\nconst instanceDataLength = 20; // n*f32 per instance\r\n\r\n\r\nconst logInstanceData = (data: Float32Array, logCount = 10) => {\r\n  const uintView = new Uint32Array(data.buffer);\r\n\r\n  let table: any = [];\r\n  // console.log(data);\r\n  for (let instance = 0; instance < logCount; instance++) {\r\n    let offset = instance * instanceDataLength;\r\n    table = [...table,  {\r\n      xPos: data[offset + 0],\r\n      yPos: data[offset + 1],\r\n      zPos: data[offset + 2],\r\n      xVel: data[offset + 4],\r\n      yVel: data[offset + 5],\r\n      zVel: data[offset + 6],\r\n      dist: data[offset + 8],\r\n      dens: data[offset + 9],\r\n      cell: uintView[offset + 10],\r\n      test: uintView[offset + 11]\r\n    }]\r\n  }\r\n  console.table(table);\r\n}\r\n\r\nfunction wgslNumStr(n: number) {\r\n  return Number.isInteger(n) ? n.toFixed(1) : n.toString();\r\n}\r\nfunction wgslVec3Str(v: Vec3) {\r\n  return `vec3<f32>(${wgslNumStr(v[0])}, ${wgslNumStr(v[1])}, ${wgslNumStr(v[2])})`;\r\n}\r\nfunction wgslIVec3Str(v: Vec3) {\r\n  const str = (n: number) => n.toFixed(0);\r\n  return `vec3<i32>(${str(v[0])}, ${str(v[1])}, ${str(v[2])})`;\r\n}\r\n\r\nexport { instanceDataLength, logInstanceData, workgroupSize, wgslNumStr, wgslVec3Str, wgslIVec3Str };", "import { renderShaders } from \"./shaders.ts\";\r\nimport { createSquareData } from \"./square.ts\";\r\nimport { instanceDataLength } from \"../common.ts\";\r\n\r\nimport { type Mat4, mat4 } from \"wgpu-matrix\"\r\n\r\nexport class WGPURenderer {\r\n  private initialised = false;\r\n\r\n  public device: GPUDevice = {} as GPUDevice;\r\n  public canvas: HTMLCanvasElement = {} as HTMLCanvasElement;\r\n  public ctx: GPUCanvasContext = {} as GPUCanvasContext;\r\n  private renderPipeline: GPURenderPipeline = {} as GPURenderPipeline; \r\n\r\n  private instanceCount = 0;\r\n  private vertexCount = 0;\r\n\r\n  private vertexBuffer: GPUBuffer = {} as GPUBuffer;\r\n  public instanceBuffer: GPUBuffer = {} as GPUBuffer;  \r\n  private uniformBuffer: GPUBuffer = {} as GPUBuffer;\r\n  private bindGroup: GPUBindGroup = {} as GPUBindGroup;\r\n\r\n  private depthTexture: GPUTexture | null = null;\r\n  private multisampleTexture: GPUTexture | null = null;\r\n\r\n  public clearColour = { r: 0.1, g: 0.1, b: 0.1, a: 1 };\r\n  public multisampleCount = 4;\r\n  \r\n  async init(): Promise<boolean> {\r\n    this.canvas = document.querySelector(\"#gpuCanvas\") as HTMLCanvasElement;\r\n\r\n    if (!navigator.gpu) {\r\n      throw Error(\"WebGPU not supported.\");\r\n    }\r\n\r\n    const adapter = await navigator.gpu.requestAdapter();\r\n    if (!adapter) {\r\n      throw Error(\"Couldn't request WebGPU adapter.\");\r\n    }\r\n\r\n\r\n    this.device = await adapter.requestDevice();\r\n    this.ctx = this.canvas.getContext(\"webgpu\") as GPUCanvasContext;\r\n\r\n    this.ctx.configure({\r\n      device: this.device,\r\n      format: navigator.gpu.getPreferredCanvasFormat(),\r\n      alphaMode: \"opaque\"\r\n    });\r\n\r\n    this.initialised = true;\r\n    return true;\r\n  }\r\n\r\n  createBuffersAndPipeline(instanceCount: number) {\r\n    const vertData = createSquareData()\r\n\r\n    this.vertexCount = vertData.length / 5;\r\n    this.instanceCount = instanceCount;\r\n\r\n    const bufferLayouts = [\r\n      // VERTEX\r\n      {\r\n        attributes: [\r\n          {\r\n            shaderLocation: 0,\r\n            offset: 0,\r\n            format: \"float32x3\"\r\n          },\r\n          {\r\n            shaderLocation: 1,\r\n            offset: 12,\r\n            format: \"float32x2\"\r\n          }\r\n        ],\r\n        arrayStride: 20,\r\n        stepMode: \"vertex\"\r\n      } as GPUVertexBufferLayout,\r\n\r\n      // INSTANCE\r\n      {\r\n        attributes: [\r\n          { // position\r\n            shaderLocation: 2,\r\n            offset: 0,\r\n            format: \"float32x4\"\r\n          },\r\n          { // velocity\r\n            shaderLocation: 3,\r\n            offset: 16,\r\n            format: \"float32x4\"\r\n          },\r\n          { // normal\r\n            shaderLocation: 4,\r\n            offset: 32,\r\n            format: \"float32x4\"\r\n          },\r\n          { // field dist\r\n            shaderLocation: 5,\r\n            offset: 48,\r\n            format: \"float32\"\r\n          },\r\n          { // density\r\n            shaderLocation: 6,\r\n            offset: 52,\r\n            format: \"float32\"\r\n          },\r\n          { // density\r\n            shaderLocation: 7,\r\n            offset: 56,\r\n            format: \"uint32\"\r\n          },\r\n          { // density\r\n            shaderLocation: 8,\r\n            offset: 60,\r\n            format: \"float32\"\r\n          }\r\n        ],\r\n        arrayStride: instanceDataLength * 4,\r\n        stepMode: \"instance\"\r\n      } as GPUVertexBufferLayout,\r\n    ];\r\n\r\n    const shaderModule = this.device.createShaderModule({code: renderShaders});\r\n    this.renderPipeline = this.device.createRenderPipeline({\r\n      vertex: {\r\n        module: shaderModule,\r\n        entryPoint: \"vertex_main\",\r\n        buffers: bufferLayouts\r\n      },\r\n      fragment: {\r\n        module: shaderModule,\r\n        entryPoint: \"fragment_main\",\r\n        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }]\r\n      },\r\n      primitive: {\r\n        topology: \"triangle-list\",\r\n        // frontFace: \"ccw\",\r\n        // cullMode: \"back\"\r\n        cullMode: \"none\"\r\n      },\r\n      depthStencil: {\r\n        depthWriteEnabled: true,\r\n        depthCompare: 'less',\r\n        format: 'depth24plus',\r\n      },\r\n      layout: \"auto\",\r\n      multisample: {\r\n        count: this.multisampleCount,\r\n      },\r\n    });\r\n\r\n\r\n    // CREATE BUFFERS\r\n\r\n    this.vertexBuffer = this.device.createBuffer({\r\n      size: vertData.byteLength,\r\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\r\n    });\r\n    this.device.queue.writeBuffer(this.vertexBuffer, 0, vertData as Float32Array<ArrayBuffer>, 0, vertData.length);\r\n    this.instanceBuffer = this.device.createBuffer({\r\n      size: this.instanceCount * 4 * instanceDataLength,\r\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\r\n    });\r\n\r\n    \r\n    // UNIFORMS\r\n    const uniformSize =\r\n      16 * 4 +  // view-proj matrix\r\n      16 * 4 +  // inverse view-proj matrix\r\n      4 * 4 +   // background colour\r\n      3 * 4 + // cam pos\r\n      1 * 4;  // aspect ratio\r\n    this.uniformBuffer = this.device.createBuffer({\r\n      size: uniformSize,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\r\n    });\r\n    \r\n    this.bindGroup = this.device.createBindGroup({\r\n      layout: this.renderPipeline.getBindGroupLayout(0),\r\n      entries: [\r\n        { binding: 0, resource: { buffer: this.uniformBuffer }},\r\n      ],\r\n    });\r\n\r\n  }\r\n\r\n\r\n  render(viewProjectionMatrix: Mat4, camPos: Float32Array) {\r\n    if (!this.initialised) {\r\n      throw (\"WebGPU not initialised\");\r\n    }\r\n\r\n\r\n    const canvasTexture = this.ctx.getCurrentTexture();\r\n\r\n    // place in uniforms\r\n    const uniformData = new Float32Array([\r\n      ...viewProjectionMatrix, \r\n      ...mat4.inverse(viewProjectionMatrix),\r\n      this.clearColour.r, this.clearColour.g, this.clearColour.b, this.clearColour.a,\r\n      ...camPos,\r\n      canvasTexture.width / canvasTexture.height])\r\n    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData, 0);\r\n\r\n    // create depth texture if needed\r\n    if (!this.depthTexture || this.depthTexture.width !== canvasTexture.width || this.depthTexture.height !== canvasTexture.height) {\r\n      this.depthTexture?.destroy();\r\n      this.depthTexture = this.device.createTexture({\r\n        size: canvasTexture,  // canvasTexture has width, height, and depthOrArrayLayers properties\r\n        format: 'depth24plus',\r\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n        sampleCount: this.multisampleCount,\r\n      });\r\n    }\r\n\r\n    // If the multisample texture doesn't exist or\r\n    // is the wrong size then make a new one.\r\n    if (!this.multisampleTexture ||\r\n        this.multisampleTexture.width !== canvasTexture.width ||\r\n        this.multisampleTexture.height !== canvasTexture.height) {\r\n \r\n      if (this.multisampleTexture) this.multisampleTexture.destroy();\r\n \r\n      // Create a new multisample texture that matches our\r\n      // canvas's size\r\n      this.multisampleTexture = this.device.createTexture({\r\n        format: canvasTexture.format,\r\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n        size: [canvasTexture.width, canvasTexture.height],\r\n        sampleCount: this.multisampleCount,\r\n      });\r\n    }\r\n\r\n\r\n    const commandEncoder = this.device.createCommandEncoder();\r\n    const passEncoder = commandEncoder.beginRenderPass({\r\n      colorAttachments: [\r\n        {\r\n          clearValue: this.clearColour,\r\n          loadOp: \"clear\",\r\n          storeOp: \"store\",\r\n          view: this.multisampleTexture.createView(),\r\n          resolveTarget: canvasTexture.createView()\r\n        }\r\n      ],\r\n      depthStencilAttachment: {\r\n        depthClearValue: 1.0,\r\n        depthLoadOp: 'clear',\r\n        depthStoreOp: 'store',\r\n        view: this.depthTexture.createView()\r\n      }\r\n    });\r\n\r\n    passEncoder.setPipeline(this.renderPipeline);\r\n    passEncoder.setVertexBuffer(0, this.vertexBuffer);\r\n    passEncoder.setVertexBuffer(1, this.instanceBuffer);\r\n    passEncoder.setBindGroup(0, this.bindGroup);\r\n    passEncoder.draw(this.vertexCount, this.instanceCount, 0, 0);\r\n\r\n    passEncoder.end();\r\n    this.device.queue.submit([commandEncoder.finish()]);\r\n  }\r\n}", "import { wgslNumStr as str, wgslVec3Str as strV, wgslIVec3Str as strIntV } from \"../../../common\"\r\nimport { vec3 } from \"wgpu-matrix\"\r\n\r\n\r\nexport const smoothingRadius = 1; // SPH smoothing radius, also defines the grid cell size\r\n\r\n// unit size of spatial grid. this is centred around 0, so will span [-0.5*bound, +0.5*bound]\r\n// points outside the bounds will be modulo'd \r\nconst bound = vec3.create(200, 100, 25); \r\n\r\nexport const gridSize = vec3.floor(vec3.divScalar(bound, smoothingRadius));\r\nexport const trueBound = vec3.mulScalar(gridSize, smoothingRadius); // reduce bound to nearest multiple of smoothingRadius\r\n\r\n\r\n// console.log(strIntV(gridSize));\r\n// console.log(strV(trueBound));\r\n\r\n\r\nexport const gridAccessFuncs = /* wgsl */`\r\n\r\nconst gridSize = ${strIntV(gridSize)};\r\nconst bounds = ${strV(trueBound)};\r\n\r\nconst cellWidth = ${str(smoothingRadius)};\r\n\r\n\r\nfn imod3(a: vec3<i32>, b: vec3<i32>) -> vec3<i32> {\r\n  let r = a % b;\r\n  return select(r + b, r, r >= vec3<i32>(0));\r\n}\r\n\r\nfn getCellIdFlat(cellId3D: vec3<i32>) -> u32 {\r\n  // TODO - could change loop for better spatial locality\r\n  // e.g. if gridSize.x = 20, currently 21 =>  1, 22 =>  2, 41 => 1\r\n  // but could flip this 20-40 range so 21 => 19, 22 => 18, 41 => 1\r\n  let loopedId3D = imod3(cellId3D, gridSize);\r\n\r\n  // TODO - use a space filling curve to improve neighbour locality\r\n  let flatId =\r\n    loopedId3D.x * gridSize.y * gridSize.z +\r\n    loopedId3D.y * gridSize.z +\r\n    loopedId3D.z;\r\n  \r\n  return u32(flatId);\r\n}\r\n\r\nfn getCellId3d(cellIdFlat: u32) -> vec3<i32> {\r\n    const yz = gridSize.y * gridSize.z;\r\n\r\n    let x = i32(cellIdFlat) / yz;\r\n    let rem = i32(cellIdFlat) % yz;\r\n\r\n    let y = rem / gridSize.z;\r\n    let z = rem % gridSize.z;\r\n\r\n    return vec3<i32>(x, y, z);\r\n}\r\n`;\r\n\r\n\r\n\r\nexport const iterateNeighbours = (body: string) => /* wgsl */`\r\n// requires including gridAccessFuncs\r\n// assumes \"particle\" is defined as the particle we are finding neighbours of\r\n// loops over all \"particleB\" in this cell and neighbour cells\r\n// uses the sorted spatial grid we have created\r\n\r\nlet particleCellIndex3d = getCellId3d(particle.cellIndex);\r\nfor (var i: i32 = -1; i <= 1; i++) {\r\n  for (var j: i32 = -1; j <= 1; j++) {\r\n    for (var k: i32 = -1; k <= 1; k++) {\r\n      let neighbourIndex3d = particleCellIndex3d + vec3<i32>(i, j, k);\r\n      let neighbourCellIndex = getCellIdFlat(neighbourIndex3d);\r\n\r\n      // get the start of the cell sublist of particles \r\n      var neighbourIterator = cellOffsets[neighbourCellIndex];\r\n\r\n      // iterate over particles in the neighbour cell\r\n      while (neighbourIterator != 0xffffffff && neighbourIterator < uniforms.particleCount) {\r\n        // let particleBIndex = particleIds[neighbourIterator]; // if we haven't reordered the particle buffer by cellId\r\n        let particleBIndex = neighbourIterator;\r\n        let particleB = particles0[particleBIndex];\r\n\r\n        if (particleB.cellIndex != neighbourCellIndex) {\r\n          // we have iterated over all particles in the neighbour cell sublist\r\n          break;\r\n        }\r\n\r\n        ${body};\r\n\r\n        neighbourIterator++;\r\n      }\r\n    }\r\n  }\r\n}\r\n`;\r\n", "export const particleStruct = /* wgsl */`\r\nstruct Particle {\r\n  position: vec4<f32>, // xyz used\r\n  velocity: vec4<f32>, // xyz used\r\n  normal: vec4<f32>,\r\n  lastDist: f32,\r\n  density: f32,\r\n  cellIndex: u32,\r\n  group: f32,\r\n  groupCentroid: vec4<f32>\r\n}\r\nconst UNSPAWNED_PARTICLE: u32 = 0xFFFFFFFF;\r\n`;\r\n\r\n\r\nexport const shaderInputLayoutSrc = /* wgsl */`\r\n${particleStruct}\r\n@group(0) @binding(0) var<storage, read_write> particles0: array<Particle>;\r\n@group(0) @binding(1) var<storage, read_write> particles1: array<Particle>;\r\n\r\nstruct Uniforms {\r\n  time: f32,\r\n  deltaTime: f32,\r\n  mouseIntersection: vec2<f32>,\r\n  lastMouseIntersection: vec2<f32>,\r\n  animSpeed: f32,\r\n  particleCount: u32,\r\n}\r\n@group(0) @binding(2) var<uniform> uniforms: Uniforms;\r\n@group(0) @binding(3) var<storage, read_write> cellIds: array<u32>;\r\n@group(0) @binding(4) var<storage, read_write> particleIds: array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> cellOffsets: array<u32>;\r\n\r\n`;\r\n\r\n\r\nimport { workgroupSize } from \"../../common\";\r\n\r\n// main function dispatch size + id gen - for shaders iterating over each particle once\r\nexport const mainFunc = /* wgsl */`\r\n@compute @workgroup_size(${workgroupSize}, 1, 1) fn update(\r\n  @builtin(workgroup_id) workgroup_id : vec3<u32>,\r\n  @builtin(local_invocation_id) local_invocation_id : vec3<u32>\r\n)\r\n`;\r\n\r\nexport const getID = /* wgsl */`workgroup_id.x * ${workgroupSize} + local_invocation_id.x`;", "import { shaderInputLayoutSrc, mainFunc, getID } from \"../shaderLayout\";\r\nimport { gridAccessFuncs } from \"./gridAccess\"\r\n\r\n\r\n\r\n// ---------- SHADER ----------\r\nexport const assignCellShaderSrc = /* wgsl */`\r\n\r\n${shaderInputLayoutSrc}\r\n\r\n\r\n${gridAccessFuncs}\r\n\r\n\r\n${mainFunc} {\r\n  let id = ${getID};\r\n\r\n  var position = particles0[id].position.xyz;\r\n  position += bounds * 0.5; // offset so grid bounding box applies from [-0.5*bound, +0.5*bound]\r\n  \r\n  var cellId3D = vec3<i32>(floor(position / cellWidth));\r\n  var cellIdFlat = getCellIdFlat(cellId3D);\r\n\r\n  // cellIdFlat = select(cellIdFlat, UNSPAWNED_PARTICLE, id >= uniforms.particleCount);\r\n\r\n  particles0[id].cellIndex = cellIdFlat;\r\n  particles1[id].cellIndex = cellIdFlat;\r\n\r\n  cellIds[id] = cellIdFlat;\r\n  particleIds[id] = id;\r\n}\r\n\r\n`;\r\n", "import { mainFunc, getID, shaderInputLayoutSrc } from \"../shaderLayout\";\r\n\r\n// creates offset list\r\n// orders particles0 list by cellID, using the (particleID, cellID) list. this isn't necessary for correctness but speeds up access\r\n\r\n\r\nexport const createStructureSrc = /* wgsl */`\r\n\r\n${shaderInputLayoutSrc.replace(\"cellOffsets: array<u32>\", \"cellOffsets: array<atomic<u32>>\")}\r\n\r\n${mainFunc} {\r\n  let id = ${getID};\r\n\r\n  let particleId = particleIds[id]; // index of this cell within the particles buffer\r\n  let cellId = cellIds[id];\r\n\r\n  particles0[id] = particles1[particleId];\r\n\r\n  \r\n\r\n\r\n  // the offset to the first appearance of each cell within the sorted cellId list is the minimum of ids\r\n  atomicMin(&cellOffsets[cellId], id);\r\n}\r\n`;", "// https://wickedengine.net/2018/05/scalabe-gpu-fluid-simulation/comment-page-1/\r\n\r\nimport { wgslNumStr as str } from \"../../../common.ts\";\r\nimport { smoothingRadius, iterateNeighbours } from \"../grid/gridAccess.ts\";\r\n\r\n\r\n// PARAMETERS\r\n\r\n// fraction of h that is used when finding density\r\n// means viscosity is influenced by further neighbours than pressure\r\n// should be <= 1\r\nconst densityNeighbourFraction = 0.8;\r\n\r\nconst pressureConstant = 250;\r\nconst referenceDensity = 1;\r\n\r\nconst viscosityConstant = 0.118;\r\n\r\nconst particleMass = 1;\r\n\r\n\r\n\r\n// INTERNAL PARAMS\r\nconst poly6const = str(315 / (64 * Math.PI * Math.pow(smoothingRadius, 9)));\r\nconst spikyConst = str(-45 / (Math.PI * Math.pow(smoothingRadius, 6)));\r\nconst viscConst = str(45 / (Math.PI * Math.pow(smoothingRadius, 6)));\r\n\r\n// ------ SHADER ------\r\nexport const sphSrc = /* wgsl */`\r\n\r\nconst h = ${str(smoothingRadius)};\r\nconst h2 = ${str(Math.pow(smoothingRadius, 2))};\r\nconst h3 = ${str(Math.pow(smoothingRadius, 3))};\r\n\r\nconst densityH = ${str(smoothingRadius * densityNeighbourFraction)};\r\nconst densityH2 = ${str(Math.pow(smoothingRadius * densityNeighbourFraction, 2))};\r\n\r\nconst particleFluidMass = ${str(particleMass)};\r\nconst p0 = ${str(referenceDensity)};\r\nconst K = ${str(pressureConstant)};\r\nconst e = ${str(viscosityConstant)};\r\n\r\nfn particleDensity(particle: Particle) -> vec4<f32> {\r\n  // also finds group neighbour centroid (.yzw of return)\r\n  var density = 0.0;\r\n\r\n  var groupCentroid = particle.position.xyz;\r\n  var groupNeighbourCount = 1.0;\r\n\r\n  ${iterateNeighbours(/* wgsl */`\r\n    let diff = particle.position.xyz - particleB.position.xyz;\r\n    let r2 = dot(diff, diff);\r\n    if (r2 < h2) {\r\n      let W = ${poly6const} * pow(h2 - r2, 3.0);\r\n      density += particleFluidMass * W;\r\n\r\n      let groupDist = 0.5*abs(particle.group - particleB.group); // 0 if the same, 1 if different\r\n      groupCentroid += (1.0-groupDist) * particleB.position.xyz; \r\n      groupNeighbourCount += 1.0-groupDist;\r\n    }\r\n  `)}\r\n\r\n  groupCentroid /= groupNeighbourCount;\r\n  \r\n\r\n  return vec4<f32>(max(p0, density), groupCentroid.x, groupCentroid.y, groupCentroid.z);\r\n}\r\n\r\nfn particlePressure(density: f32) -> f32 {\r\n  return K * (density - p0);\r\n}\r\n\r\nfn fluidAccel(particle: Particle, id: u32) -> vec3<f32> {\r\n  var pressureForce = vec3<f32>(0.0);\r\n  var viscosityForce = vec3<f32>(0.0);\r\n\r\n  let pressureA = particlePressure(particle.density);\r\n\r\n  var groupNeighbourPosSum = vec3<f32>(0.0);\r\n  var neighbourCount = 0.01;\r\n  \r\n  ${iterateNeighbours(/* wgsl */`\r\n    if (particleBIndex != id) {\r\n\r\n      let diff = particle.position.xyz - particleB.position.xyz;\r\n      let r2 = dot(diff, diff);\r\n        let r = sqrt(r2);\r\n\r\n      if (r2 > 0 && r2 < h2) {\r\n        let rNorm = diff / r;\r\n        let r3 = r2 * r;\r\n\r\n        let groupDist = 0.5*abs(particle.group - particleB.group); // 0 if the same, 1 if different\r\n\r\n        // PRESSURE FORCE\r\n        let W1 = ${spikyConst} * pow(h-r, 2.0);\r\n        let pressureB = (1.0 + 10.0*groupDist) * particlePressure(particleB.density);\r\n        pressureForce += W1 * rNorm * (pressureA + pressureB) / (2.0 * particle.density * particleB.density);\r\n\r\n\r\n        // VISCOSITY FORCE\r\n        // let W2 = -(r3 / (2.0 * h3)) + (r2 / h2) + (h / (2.0 * r)) - 1;\r\n        var W2 = ${viscConst} * (h - r);\r\n        viscosityForce += (1.0-2.0*groupDist) * W2 * rNorm * (particleB.velocity.xyz - particle.velocity.xyz) / particleB.density;\r\n\r\n\r\n        // GROUP COHESION\r\n        // move towards particles of same group\r\n        groupNeighbourPosSum += (1.0-groupDist) * particleB.groupCentroid.xyz; \r\n        neighbourCount += 1.0-groupDist;\r\n        \r\n      }\r\n    }\r\n  `)}\r\n\r\n  var force = (e*viscosityForce - pressureForce) / particle.density;\r\n\r\n\r\n  // group cohesion force (disabled)\r\n  // // let sameGroupCentroidDir = (sameGroupNeighbourPosSum.xyz / sameGroupNeighbourPosSum.w) - particle.position.xyz;\r\n  // // let diffGroupCentroidDir = (diffGroupNeighbourPosSum.xyz / diffGroupNeighbourPosSum.w) - particle.position.xyz;\r\n  // // force += 0.3* sameGroupCentroidDir - 0.0*diffGroupCentroidDir;\r\n  // force += 1.0 * (groupNeighbourPosSum / neighbourCount - particle.position.xyz);\r\n\r\n  return force / particleFluidMass;\r\n}\r\n\r\n\r\n`;", "import { shaderInputLayoutSrc, mainFunc, getID } from \"./shaderLayout\";\r\nimport { gridAccessFuncs } from \"./grid/gridAccess\";\r\nimport { sphSrc } from \"./physics/sph\";\r\n\r\n\r\n// compute densities\r\n\r\n\r\nexport const update1Src = /* wgsl */`\r\n\r\n${shaderInputLayoutSrc}\r\n${gridAccessFuncs}\r\n${sphSrc}\r\n\r\n\r\n${mainFunc} {\r\n  let id = ${getID};\r\n\r\n  let densityAndCentroid = particleDensity(particles0[id]);\r\n\r\n  particles0[id].density = densityAndCentroid.x;\r\n  particles0[id].groupCentroid = vec4<f32>(densityAndCentroid.yzw, 1.0);\r\n}\r\n\r\n`;", "import { wgslNumStr as str } from \"../../../common\";\r\n\r\nconst mass = str(0.05);\r\nconst positionStiffness = str(-2);\r\nconst velocityDamping = str(-1);\r\nconst gravityClamp = str(200); // limit gravity so it doesn't explode if we're far away\r\n\r\n\r\nexport const sdfSrc = /* wgsl */`\r\n\r\nconst internalForceMultiplier = 1.0; // scale the force when particle is inside field (currently not working i think)\r\n\r\nfn sdCapsule(p: vec3<f32>, a: vec3<f32>, b: vec3<f32>, r: f32) -> f32 {\r\n    let pa = p - a;\r\n    let ba = b - a;\r\n    let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\r\n    return length(pa - ba * h) - r;\r\n}\r\n\r\nfn sdCappedTorus(pIn: vec3<f32>, sc: vec2<f32>, ra: f32, rb: f32) -> f32 {\r\n    var p = pIn;\r\n    p.y = abs(p.y);\r\n\r\n    let p_xy = p.xy;\r\n    let k = select(\r\n        length(p_xy),\r\n        dot(p_xy, sc),\r\n        sc.y * p.y > sc.x * p.x\r\n    );\r\n\r\n    return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\r\n}\r\n\r\nfn sdD(p: vec3<f32>, r: f32) -> f32 {\r\n    let c1 = sdCapsule(p,\r\n        vec3<f32>(-0.3, -0.5, 0.0),\r\n        vec3<f32>(-0.3,  0.5, 0.0), r);\r\n\r\n    let c2 = sdCapsule(p,\r\n        vec3<f32>(-0.3, -0.5, 0.0),\r\n        vec3<f32>(-0.1, -0.5, 0.0), r);\r\n\r\n    let c3 = sdCapsule(p,\r\n        vec3<f32>(-0.3,  0.5, 0.0),\r\n        vec3<f32>(-0.1,  0.5, 0.0), r);\r\n\r\n    let t1 = sdCappedTorus(\r\n        p - vec3<f32>(-0.1, 0.0, 0.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        0.5, r\r\n    );\r\n\r\n    return min(min(c1, c2), min(c3, t1));\r\n}\r\n\r\nfn sdE(p: vec3<f32>, r: f32) -> f32 {\r\n    let c1 = sdCapsule(p,\r\n        vec3<f32>(-0.3,  0.5, 0.0),\r\n        vec3<f32>( 0.3,  0.5, 0.0), r);\r\n\r\n    let c2 = sdCapsule(p,\r\n        vec3<f32>(-0.3,  0.0, 0.0),\r\n        vec3<f32>( 0.1,  0.0, 0.0), r);\r\n\r\n    let c3 = sdCapsule(p,\r\n        vec3<f32>(-0.3, -0.5, 0.0),\r\n        vec3<f32>( 0.3, -0.5, 0.0), r);\r\n\r\n    let c4 = sdCapsule(p,\r\n        vec3<f32>(-0.3, -0.5, 0.0),\r\n        vec3<f32>(-0.3,  0.5, 0.0), r);\r\n\r\n    return min(min(c1, c2), min(c3, c4));\r\n}\r\n\r\nfn sdI(p: vec3<f32>, r: f32) -> f32 {\r\n    let c1 = sdCapsule(\r\n        p,\r\n        vec3<f32>(0.0, -0.5, 0.0),\r\n        vec3<f32>(0.0,  0.5, 0.0),\r\n        r\r\n    );\r\n    let c2 = sdCapsule(\r\n        p,\r\n        vec3<f32>(-0.3, 0.5, 0.0),\r\n        vec3<f32>( 0.3, 0.5, 0.0),\r\n        r\r\n    );\r\n    let c3 = sdCapsule(\r\n        p,\r\n        vec3<f32>(-0.3, -0.5, 0.0),\r\n        vec3<f32>( 0.3, -0.5, 0.0),\r\n        r\r\n    );\r\n    return min(c1, min(c2, c3));\r\n}\r\n\r\nfn sdDistort(pos: vec3<f32>) -> f32 {\r\n    // const sharpness = 0.9;\r\n    // const period = 0.5;\r\n    // return max((sin(period*abs(pos.y) + uniforms.time)-sharpness)/(1.0-sharpness), 0.0);\r\n\r\n\r\n    // MOUSE INTERACTION\r\n\r\n    // find closest point on line between mouseIntersection and lastMouseIntersection\r\n    let p1 = uniforms.mouseIntersection;\r\n    let p2 = uniforms.lastMouseIntersection;  \r\n    \r\n    let v = p2 - p1;\r\n    let w = pos.xy - p1;\r\n\r\n    let t = saturate(dot(w, v) / dot(v, v));\r\n    let closestPoint = p1 + t*v;\r\n\r\n\r\n    const mouseDisturbRadius = 5.0;\r\n    const mouseDisturbSharpness = 18.0;\r\n\r\n    var dist = pos.xy - closestPoint;\r\n    dist *= 1.0/mouseDisturbRadius;\r\n    \r\n\r\n    return mouseDisturbSharpness*exp(-dot(dist, dist));\r\n}\r\n\r\nfn sdf(pos: vec3<f32>) -> f32 {\r\n    const r: f32 = 0.08;\r\n    const scale: f32 = 40.0;\r\n\r\n    let p = pos / scale;\r\n    var minDist: f32 = 1e20;\r\n\r\n    // E\r\n    minDist = min(minDist, sdE(p - vec3<f32>(-2.05, 0.0, 0.0), r) * scale);\r\n\r\n    // D D\r\n    minDist = min(minDist, sdD(p - vec3<f32>(-1.05, 0.0, 0.0), r) * scale);\r\n    minDist = min(minDist, sdD(p - vec3<f32>( 0.0, 0.0, 0.0), r) * scale);\r\n\r\n    // I\r\n    minDist = min(minDist, sdI(p - vec3<f32>( 1.0, 0.0, 0.0), r) * scale);\r\n\r\n    // E\r\n    minDist = min(minDist, sdE(p - vec3<f32>( 2.0, 0.0, 0.0), r) * scale);\r\n\r\n    minDist += sdDistort(pos);\r\n\r\n    return minDist;\r\n}\r\n\r\nconst EPSILON: f32 = 0.0001;\r\nfn sdfNormal(pos: vec3<f32>) -> vec3<f32> {\r\n    let e = vec3<f32>(EPSILON, 0.0, 0.0);\r\n\r\n    let dx = sdf(pos + e.xyy) - sdf(pos - e.xyy);\r\n    let dy = sdf(pos + e.yxy) - sdf(pos - e.yxy);\r\n    let dz = sdf(pos + e.yyx) - sdf(pos - e.yyx);\r\n\r\n    return normalize(vec3<f32>(dx, dy, dz));\r\n}\r\n\r\nconst gravityClamp = ${gravityClamp};\r\nfn gravityAccel(pos: vec3<f32>, dist: f32, fieldNormal: vec3<f32>, lastDist: f32) -> vec3<f32> {\r\n  let dist2 = dist; // max(dist, 0.0);         // uncomment to allow particles inside volumes\r\n  let lastDist2 = lastDist; // max(lastDist, 0.0);\r\n\r\n  let dDistdt = (dist2 - lastDist2) / uniforms.deltaTime;\r\n  var gravityAmount = -${positionStiffness}*dist2 - ${velocityDamping}*dDistdt;\r\n  gravityAmount = atan(gravityAmount / gravityClamp) * gravityClamp;\r\n\r\n  var gravity = -fieldNormal * gravityAmount;\r\n\r\n  return gravity / ${mass};\r\n\r\n}\r\n\r\n\r\n`;", "import { shaderInputLayoutSrc, mainFunc, getID } from \"./shaderLayout\";\r\nimport { gridAccessFuncs } from \"./grid/gridAccess\";\r\nimport { sdfSrc } from \"./physics/sdf\";\r\nimport { sphSrc } from \"./physics/sph\";\r\n\r\n\r\n// compute pressure and viscosity forces\r\n\r\nexport const update2Src = /* wgsl */`\r\n\r\n${shaderInputLayoutSrc}\r\n${gridAccessFuncs}\r\n${sphSrc}\r\n${sdfSrc}\r\n\r\nconst accelDeltaTime = 0.01; // hardcoded deltaTime for acceleration calculation to prevent explosion\r\nconst velocityClamp = 100.0;\r\n\r\n\r\n${mainFunc} {\r\n  let id = ${getID};\r\n  let particle = particles0[id];\r\n\r\n  var position = particle.position.xyz;\r\n  var velocity = particle.velocity.xyz;\r\n\r\n\r\n  \r\n  // fluid force\r\n  var acceleration = fluidAccel(particle, id);\r\n  \r\n  // field gravity\r\n  let fieldDist = sdf(position);\r\n  let fieldNormal = sdfNormal(position);\r\n  acceleration += gravityAccel(position, fieldDist, fieldNormal, particle.lastDist);\r\n\r\n  // group move to top/bottom\r\n  acceleration += vec3<f32>(0.0, -3.0*particle.group, 0.0);\r\n  \r\n  // apply forces\r\n  velocity += acceleration * accelDeltaTime;\r\n  velocity = atan(velocity / velocityClamp) * velocityClamp ;\r\n\r\n  position += velocity * uniforms.deltaTime * uniforms.animSpeed;\r\n\r\n  \r\n  \r\n  // particle normal (shading only) - move towards field normal\r\n  const lerpSpeed = 0.1;\r\n  let normal = normalize(lerpSpeed*fieldNormal + (1.0-lerpSpeed)*particle.normal.xyz);\r\n\r\n\r\n  \r\n  particles1[id] = Particle(\r\n    vec4<f32>(position, 1.0),\r\n    vec4<f32>(velocity, 1.0),\r\n    vec4<f32>(normal, 1.0),\r\n    fieldDist,\r\n    particle.density,\r\n    particle.cellIndex, // not really necessary\r\n    particle.group,\r\n    particle.groupCentroid\r\n  );\r\n\r\n}\r\n`;", "// https://wickedengine.net/2018/05/scalabe-gpu-fluid-simulation/comment-page-1/\r\n\r\nimport { instanceDataLength, logInstanceData, workgroupSize } from \"../common\";\r\nimport { gridSize } from \"./shader/grid/gridAccess\";\r\n\r\nimport { assignCellShaderSrc } from \"./shader/grid/assignCell\";\r\nimport { createStructureSrc } from \"./shader/grid/createStructure\";\r\nimport { update1Src } from \"./shader/update1\";\r\nimport { update2Src } from \"./shader/update2\";\r\n\r\nimport { RadixSortKernel } from 'webgpu-radix-sort';\r\n\r\nimport { type Vec2 } from \"wgpu-matrix\";\r\n\r\n\r\nexport class WGPUComputer {\r\n  private device: GPUDevice;\r\n\r\n  private computeShaders = [assignCellShaderSrc, createStructureSrc, update1Src, update2Src]; // run in order, with a sort between shader[0] and shader[1]\r\n\r\n  private pipelines: GPUComputePipeline[] = [];\r\n  private bindGroup: GPUBindGroup;\r\n  \r\n  private particleCount = 0;\r\n  private maxParticleCount: number;\r\n  private readonly spawnPeriod = 3; // duration (seconds) of initial period where particles spawn in\r\n\r\n\r\n  private particleDataBuffer0: GPUBuffer; // used as read/write for all but the final shader. used as read for final shader\r\n  private particleDataBuffer1: GPUBuffer; // used as write for final shader (to avoid race conditions)\r\n\r\n  private renderInstanceBuffer: GPUBuffer;\r\n\r\n  // particles are given in a tuple (cellIndex, particleIndex in particleDataBuffer)\r\n  // we sort these tuples by cellIndex, creating sublists in the list of tuples for each cell\r\n  private cellIndexBuffer: GPUBuffer;\r\n  private particleIdBuffer: GPUBuffer;\r\n\r\n  private cellOffsetBuffer: GPUBuffer; // stores the offset each cell has in the sorted cellIndex array (0xffffffff if cell is empty)\r\n  private cellOffsetStartBuffer: GPUBuffer; // buffer of 0xffffffff to reset cellOffset every frame - currently no encoder.fillBuffer :(\r\n\r\n\r\n  private uniformBuffer: GPUBuffer;\r\n  private time = 0;\r\n\r\n\r\n  private uniforms = new Map<string, {length: number, value: Float32Array | Uint32Array}>([\r\n    [\"time\",                  {length: 1, value: new Float32Array([0])}],\r\n    [\"deltaTime\",             {length: 1, value: new Float32Array([0])}],\r\n    [\"mouseIntersection\",     {length: 2, value: new Float32Array([0, 0])}],\r\n    [\"lastMouseIntersection\", {length: 2, value: new Float32Array([0, 0])}],\r\n    [\"animSpeed\",             {length: 1, value: new Float32Array([0])}],\r\n    [\"particleCount\",         {length: 1, value: new Uint32Array([0])}],\r\n  ]);\r\n  private uniformsLength = Array.from(this.uniforms.values()).reduce((acc, u) => acc + u.length, 0);\r\n\r\n  private resultBuffer: GPUBuffer; // for debug\r\n\r\n\r\n  constructor(device: GPUDevice, particleCount: number, initialInstanceData: Float32Array<ArrayBuffer>, renderInstanceBuffer: GPUBuffer) {\r\n    this.device = device;\r\n    this.maxParticleCount = particleCount;\r\n    this.particleCount = 0;\r\n    this.renderInstanceBuffer = renderInstanceBuffer;\r\n\r\n    \r\n    const bindGroupLayout = this.device.createBindGroupLayout({\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: { type: \"storage\" },\r\n        },\r\n        {\r\n          binding: 1,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: { type: \"storage\" },\r\n        },\r\n        {\r\n          binding: 2,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: { type: \"uniform\" },\r\n        },\r\n        {\r\n          binding: 3,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: { type: \"storage\" },\r\n        },\r\n        {\r\n          binding: 4,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: { type: \"storage\" },\r\n        },\r\n        {\r\n          binding: 5,\r\n          visibility: GPUShaderStage.COMPUTE,\r\n          buffer: { type: \"storage\" },\r\n        },\r\n      ],\r\n    });\r\n    const pipelineLayout = this.device.createPipelineLayout({\r\n      bindGroupLayouts: [bindGroupLayout],\r\n    });\r\n\r\n    \r\n    // create a pipeline for each shader \r\n    for (let i = 0; i < this.computeShaders.length; i++) {\r\n      const module = this.device.createShaderModule({\r\n        label: `particle update ${i}`,\r\n        code: this.computeShaders[i]\r\n      });\r\n\r\n      this.pipelines.push(device.createComputePipeline({\r\n        label: `particle update ${i} pipeline`,\r\n        layout: pipelineLayout,\r\n        compute: {\r\n          module\r\n        }\r\n      }));\r\n    }\r\n\r\n    \r\n    // BUFFERS\r\n\r\n    this.particleDataBuffer0 = device.createBuffer({\r\n      size: this.maxParticleCount * 4 * instanceDataLength,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n    });\r\n    this.particleDataBuffer1 = device.createBuffer({\r\n      size: this.maxParticleCount * 4 * instanceDataLength,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n    });\r\n    device.queue.writeBuffer(this.particleDataBuffer0, 0, initialInstanceData)\r\n    device.queue.writeBuffer(this.particleDataBuffer1, 0, initialInstanceData)\r\n\r\n    this.cellIndexBuffer = device.createBuffer({\r\n      size: this.maxParticleCount * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n    })\r\n    this.particleIdBuffer = device.createBuffer({\r\n      size: this.maxParticleCount * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n    })\r\n\r\n    const cellOffsetBufSize = gridSize[0] * gridSize[1] * gridSize[2]\r\n    this.cellOffsetBuffer = device.createBuffer({\r\n      size: cellOffsetBufSize * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\r\n    });\r\n    this.cellOffsetStartBuffer = device.createBuffer({\r\n      size: cellOffsetBufSize * 4,\r\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC\r\n    })\r\n    device.queue.writeBuffer(this.cellOffsetStartBuffer, 0, new Uint32Array(cellOffsetBufSize).fill(0xffffffff))\r\n\r\n\r\n\r\n\r\n    this.uniformBuffer = device.createBuffer({\r\n      size: this.uniformsLength * 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\r\n    });\r\n\r\n    this.resultBuffer = device.createBuffer({\r\n      size: this.particleDataBuffer0.size,\r\n      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\r\n    });\r\n    \r\n\r\n\r\n    // BINDINGS\r\n    this.bindGroup = device.createBindGroup({\r\n      layout: bindGroupLayout,\r\n      entries: [\r\n        { binding: 0, resource: { buffer: this.particleDataBuffer0 }},\r\n        { binding: 1, resource: { buffer: this.particleDataBuffer1 }},\r\n        { binding: 2, resource: { buffer: this.uniformBuffer }},\r\n        { binding: 3, resource: { buffer: this.cellIndexBuffer }},\r\n        { binding: 4, resource: { buffer: this.particleIdBuffer }},\r\n        { binding: 5, resource: { buffer: this.cellOffsetBuffer }}\r\n      ],\r\n    })\r\n  }\r\n\r\n  sort(encoder: GPUCommandEncoder) {\r\n    // sort (cell id, particle id) list by cell id\r\n    const radixSortKernel = new RadixSortKernel({\r\n      device: this.device,\r\n      keys: this.cellIndexBuffer,\r\n      values: this.particleIdBuffer,\r\n      count: this.maxParticleCount,\r\n      check_order: false, \r\n      bit_count: 32,\r\n      workgroup_size: { x: 16, y: 16 },  // Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n    });\r\n    const pass = encoder.beginComputePass();\r\n    radixSortKernel.dispatch(pass);\r\n    pass.end();\r\n  }\r\n\r\n  async run(deltaTime: number, mouseIntersection: Vec2, lastMouseIntersection: Vec2) {\r\n    this.time += deltaTime;\r\n\r\n    // spawn more particles\r\n    this.particleCount += this.maxParticleCount * (deltaTime / this.spawnPeriod);\r\n    this.particleCount = Math.min(this.particleCount, this.maxParticleCount);\r\n    \r\n\r\n    // update uniforms\r\n    this.uniforms.get(\"time\")!.value[0] = this.time;\r\n    this.uniforms.get(\"deltaTime\")!.value[0] = deltaTime;\r\n    this.uniforms.get(\"mouseIntersection\")!.value = mouseIntersection;\r\n    this.uniforms.get(\"lastMouseIntersection\")!.value = lastMouseIntersection;\r\n    this.uniforms.get(\"animSpeed\")!.value[0] = window.PAUSE_UPDATE ? 0 : 1;\r\n    this.uniforms.get(\"particleCount\")!.value[0] = this.particleCount;\r\n\r\n    // write uniforms\r\n    const uniformData = new Float32Array(this.uniformsLength);\r\n    let i = 0;\r\n    for (const [_, { length, value }] of this.uniforms) {\r\n      uniformData.set(value, i);\r\n      i += length;\r\n    }\r\n    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData, 0);\r\n\r\n\r\n    \r\n    // run each compute shader\r\n    const encoder = this.device.createCommandEncoder();\r\n    encoder.copyBufferToBuffer(this.cellOffsetStartBuffer, this.cellOffsetBuffer); // reset cell offsets to max value (indicating empty cell)\r\n\r\n    const runPipeline = (pipeline: GPUComputePipeline) => {\r\n      const pass = encoder.beginComputePass();\r\n      pass.setPipeline(pipeline);\r\n      pass.setBindGroup(0, this.bindGroup);\r\n      pass.dispatchWorkgroups(this.maxParticleCount / workgroupSize, 1, 1);\r\n      pass.end();\r\n    }\r\n    \r\n    runPipeline(this.pipelines[0]); // assign cell\r\n    this.sort(encoder);\r\n    runPipeline(this.pipelines[1]); // create offset list and reorder particle data\r\n    runPipeline(this.pipelines[2]); // physics update 1\r\n    runPipeline(this.pipelines[3]); // physics update 2\r\n\r\n    encoder.copyBufferToBuffer(this.particleDataBuffer1, this.particleDataBuffer0);\r\n    encoder.copyBufferToBuffer(this.particleDataBuffer1, 0, this.renderInstanceBuffer, 0);\r\n\r\n\r\n\r\n\r\n    // DEBUGGING\r\n\r\n    const debugBuffer = \r\n      window.DEBUG_BUF === 3 ? this.cellOffsetBuffer : (\r\n      window.DEBUG_BUF === 2 ? this.particleIdBuffer : (\r\n      window.DEBUG_BUF === 1 ? this.cellIndexBuffer : this.particleDataBuffer0))\r\n    encoder.copyBufferToBuffer(debugBuffer, 0, this.resultBuffer, 0);\r\n\r\n    const commandBuffer = encoder.finish();\r\n    this.device.queue.submit([commandBuffer]);\r\n\r\n    if (window.LOG_INSTANCE_DATA) \r\n      {\r\n      // copy instance data to result buffer and print\r\n\r\n      window.LOG_INSTANCE_DATA = false;\r\n      await this.resultBuffer.mapAsync(GPUMapMode.READ);\r\n    \r\n      if (!window.DEBUG_BUF) {\r\n        const result = new Float32Array(this.resultBuffer.getMappedRange());\r\n        logInstanceData(result);\r\n      } else { \r\n        const result = new Uint32Array(this.resultBuffer.getMappedRange());\r\n        console.log(result);\r\n      }\r\n\r\n      this.resultBuffer.unmap();\r\n    }\r\n  }\r\n\r\n}", "import { mat4, vec4, vec3, vec2, type Vec3, type Mat4, type Vec2 } from 'wgpu-matrix';\r\nimport { instanceDataLength, logInstanceData } from './common';\r\n\r\nexport class Scene {\r\n  private viewDistance: number = 84;\r\n  public camPos = vec3.create(0, 0, this.viewDistance);\r\n  public viewMatrix: Mat4 = mat4.lookAt(this.camPos, [0, 0, 0], [0, 1, 0]);\r\n  public viewProjectionMatrix: Mat4 = mat4.identity();\r\n  private viewAngles: Vec2 = vec2.create(0, 0);\r\n\r\n\r\n  public mouseCoord = vec2.create(0, 0);\r\n  private mouseDown = false;\r\n  private lastMouseCoord = vec2.create(0, 0);\r\n\r\n  public mouseIntersection = vec3.create(0, 0, 0); // intersection of mouse ray with z=0 plane\r\n  public lastMouseIntersection = vec3.create(0, 0, 0);\r\n\r\n  constructor() {\r\n    window.addEventListener('mousemove', (event) => {\r\n      const rect = (event.target as HTMLCanvasElement).getBoundingClientRect();\r\n      this.mouseCoord[0] = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n      this.mouseCoord[1] = -(((event.clientY - rect.top) / rect.height) * 2 - 1);\r\n    });\r\n    window.addEventListener('mousedown', (event) => {\r\n      this.mouseDown = true;\r\n    });\r\n    window.addEventListener('mouseup', (event) => {\r\n      this.mouseDown = false;\r\n    });\r\n    window.addEventListener('wheel', (event) => {\r\n      // event.preventDefault();\r\n      this.viewDistance += 0.1 * this.viewDistance * ((event as WheelEvent).deltaY > 0 ? 1 : -1);\r\n      this.viewDistance = Math.max(5, Math.min(200, this.viewDistance));\r\n    });\r\n  }\r\n\r\n  createInitialParticleData(particleCount: number): Float32Array<ArrayBuffer> {\r\n    const particleData = new Float32Array(particleCount * instanceDataLength);\r\n\r\n    for (let i = 0; i < particleCount; i++) {\r\n\r\n\r\n      let pos = vec3.create(Math.random(), Math.random(), Math.random());\r\n      pos = vec3.sub(pos, vec3.create(0.5, 0.5, 0.5)); // 1x1 cube centred at origin\r\n      pos = vec3.multiply(pos, vec3.create(20, 50, 20));\r\n\r\n      const letterX = [-2.05, -1.05, 0, 1, 2].map(x => x*40);\r\n      const letter = Math.floor(Math.random() * letterX.length);\r\n\r\n\r\n      const side = Math.random() > 0.5 ? 1: -1;\r\n      pos = vec3.add(pos, vec3.create(letterX[letter], 80 * side, 0));\r\n\r\n      \r\n      // pos = vec3.scale(pos, 7);\r\n      // pos = vec3.add(pos, vec3.create(10, 20, 0));\r\n\r\n      // start left of E\r\n      // pos = vec3.mul(pos, vec3.create(20, 50, 10));\r\n      // pos = vec3.add(pos, vec3.create(-200, 0, 0));\r\n\r\n\r\n      // random velocity\r\n      const startMaxSpeed = 20.0;\r\n      // let velocity = vec3.create((Math.random()-0.5) * startMaxSpeed, (Math.random()-0.5) * startMaxSpeed, (Math.random()-0.5) * startMaxSpeed);\r\n      let velocity = vec3.create(0, -20, 0);\r\n\r\n      const normal = vec3.create(0, 1, 0);\r\n\r\n      particleData.set([\r\n        pos[0],       pos[1],      pos[2],      1, \r\n        velocity[0],  velocity[1], velocity[2], 1, \r\n        normal[0],    normal[1],   normal[2],   1,\r\n        0, 0, 0, side,\r\n      ], i * instanceDataLength);\r\n      \r\n    }\r\n    // logInstanceData(particleData);\r\n    return particleData;\r\n  }\r\n\r\n\r\n  update(canvas: HTMLCanvasElement) {\r\n    // console.log(this.mouseCoord);\r\n    if (this.mouseDown) {\r\n      const deltaMouse = vec2.subtract(this.mouseCoord, this.lastMouseCoord);\r\n      this.viewAngles[0] += deltaMouse[0] * 1.5;\r\n      this.viewAngles[1] += deltaMouse[1] * -1;\r\n    }\r\n\r\n\r\n    this.camPos = vec3.create(0, 0, this.viewDistance);\r\n    this.camPos = vec3.rotateX(this.camPos, vec3.zero(), this.viewAngles[1]);\r\n    this.camPos = vec3.rotateY(this.camPos, vec3.zero(), this.viewAngles[0]);\r\n    const viewMatrix = mat4.lookAt(this.camPos, [0, 0, 0], [0, 1, 0]);\r\n\r\n\r\n\r\n    const projMatrix = mat4.perspective(\r\n      1.0,\r\n      canvas.width / canvas.height,\r\n      0.1,\r\n      1000.0\r\n    );\r\n    this.viewProjectionMatrix = mat4.multiply(projMatrix, viewMatrix);\r\n\r\n\r\n\r\n    // find intersection of mouse ray with z=0 plane\r\n    const nearClip = vec4.create(this.mouseCoord[0], this.mouseCoord[1], -1, 1);\r\n    const farClip  = vec4.create(this.mouseCoord[0], this.mouseCoord[1],  1, 1);\r\n\r\n    const invVP = mat4.inverse(this.viewProjectionMatrix);\r\n    let nearWorld = vec4.transformMat4(nearClip, invVP);\r\n    let farWorld  = vec4.transformMat4(farClip, invVP);\r\n\r\n    nearWorld = vec3.create(nearWorld[0]/nearWorld[3], nearWorld[1]/nearWorld[3], nearWorld[2]/nearWorld[3] ); // perspective correction\r\n    farWorld  = vec3.create(farWorld[0]/farWorld[3], farWorld[1]/farWorld[3], farWorld[2]/farWorld[3] );\r\n\r\n    const rayOrigin = nearWorld;\r\n    const rayDir = vec3.normalize(vec3.sub(farWorld, nearWorld));\r\n    const t = -rayOrigin[2] / rayDir[2];\r\n    \r\n    this.lastMouseIntersection = this.mouseIntersection;\r\n    this.mouseIntersection = vec3.add(rayOrigin, vec3.scale(rayDir, t));\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    this.lastMouseCoord = vec2.clone(this.mouseCoord);\r\n  }\r\n\r\n}\r\n", "import {WGPURenderer} from \"./ts/render/renderer.ts\"\r\nimport { WGPUComputer } from \"./ts/compute/computer.ts\"\r\nimport { Scene } from \"./ts/scene.ts\";\r\nimport { mat4 } from \"wgpu-matrix\";\r\nimport { workgroupSize } from \"./ts/common.ts\";\r\n\r\n\r\nconst particleCount = 1600 * workgroupSize; // must be multiple of workgroupSize\r\nconst scene = new Scene();\r\n\r\n\r\n\r\nlet lastTime = Date.now();\r\nlet frameCount = 0;\r\nlet frameTimeSum = 0;\r\nfunction render(renderer: WGPURenderer, computer: WGPUComputer) {\r\n  const currentTime = Date.now();\r\n  const deltaTime = (currentTime - lastTime) / 1000;\r\n  lastTime = currentTime;\r\n\r\n  frameCount++;\r\n  frameTimeSum += deltaTime;\r\n  if (window.LOG_FPS && frameCount % 100 == 0) {\r\n    console.log(\"FPS \", 1 / (frameTimeSum / 100))\r\n    frameTimeSum = 0;\r\n  }\r\n  \r\n\r\n\r\n  scene.update(renderer.ctx.canvas as HTMLCanvasElement);\r\n\r\n  computer.run(Math.min(deltaTime, 0.1), scene.mouseIntersection, scene.lastMouseIntersection);\r\n  renderer.render(scene.viewProjectionMatrix, scene.camPos);\r\n  requestAnimationFrame(() => render(renderer, computer));\r\n}\r\n\r\n\r\nasync function main() {\r\n  const renderer = new WGPURenderer();\r\n  const success = await renderer.init()\r\n  if (!success) \r\n    return;\r\n\r\n\r\n  // resize oberserver\r\n  const observer = new ResizeObserver(entries => {\r\n    for (const entry of entries) {\r\n      const width = entry.contentBoxSize[0].inlineSize;\r\n      const height = entry.contentBoxSize[0].blockSize;\r\n      const canvas = entry.target as HTMLCanvasElement;\r\n      canvas.width = Math.max(1, Math.min(width, renderer.device.limits.maxTextureDimension2D));\r\n      canvas.height = Math.max(1, Math.min(height, renderer.device.limits.maxTextureDimension2D));\r\n    }\r\n  });\r\n  observer.observe(renderer.canvas);\r\n\r\n\r\n  const particleData = scene.createInitialParticleData(particleCount);\r\n  renderer.createBuffersAndPipeline(particleCount);\r\n  const computer = new WGPUComputer(renderer.device, particleCount, particleData, renderer.instanceBuffer);\r\n\r\n  \r\n\r\n  lastTime = Date.now();\r\n  requestAnimationFrame(() => render(renderer, computer));\r\n}\r\n\r\nmain()"],
  "mappings": "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KAAK;AACH,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC;QAEF,KAAK;AACH,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC;QAEF,KAAK;AACH,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC;QAEF,KAAK;AACH,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC;QAEF,KAAK;AACH,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC;QAEF,KAAK;AACH,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK;AACrC,iBAAO,CAAC,IAAI,KAAK,KAAK,KAAK,KAA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",
  "names": ["prefixSumSource", "prefixSumNoBankConflictSource", "find_optimal_dispatch_size", "device", "workgroup_count", "dispatchSize", "x", "y", "limits", "maxComputeWorkgroupsPerDimension", "Math", "floor", "sqrt", "ceil", "create_buffer_from_data", "_ref", "label", "data", "_ref$usage", "usage", "dispatchSizes", "createBuffer", "size", "length", "mappedAtCreation", "dispatchData", "Uint32Array", "getMappedRange", "set", "unmap", "PrefixSumKernel", "count", "_ref$workgroup_size", "workgroup_size", "_ref$avoid_bank_confl", "avoid_bank_conflicts", "_classCallCheck", "threads_per_workgroup", "items_per_workgroup", "log2", "Error", "concat", "pipelines", "shaderModule", "createShaderModule", "code", "prefixSumSource_NoBankConflict", "create_pass_recursive", "_createClass", "key", "value", "blockSumBuffer", "GPUBufferUsage", "STORAGE", "COPY_SRC", "COPY_DST", "bindGroupLayout", "createBindGroupLayout", "entries", "binding", "visibility", "GPUShaderStage", "COMPUTE", "buffer", "type", "bindGroup", "createBindGroup", "layout", "resource", "pipelineLayout", "createPipelineLayout", "bindGroupLayouts", "scanPipeline", "createComputePipeline", "compute", "module", "entryPoint", "constants", "push", "pipeline", "blockSumPipeline", "get_dispatch_chain", "flatMap", "p", "dispatch", "pass", "dispatchSizeBuffer", "offset", "arguments", "undefined", "i", "_this$pipelines$i", "setPipeline", "setBindGroup", "dispatchWorkgroups", "dispatchWorkgroupsIndirect", "radixSortSource", "radixSortCoalescedSource", "radixSortReorderSource", "checkSortSource", "isFirstPass", "isLastPass", "kernelMode", "first_pass_load_data", "last_pass", "write_reduction_result", "last_pass_full", "last_pass_fast", "CheckSortKernel", "result", "original", "is_sorted", "_ref$start", "start", "_ref$mode", "mode", "buffers", "outputs", "create_passes_recursive", "passIndex", "outputBuffer", "_toConsumableArray", "element_count", "start_element", "checkSortPipeline", "_objectSpread", "dispatchIndirect", "find_optimal_dispatch_chain", "item_count", "sizes", "target_workgroup_count", "_RadixSortKernel_brand", "WeakSet", "RadixSortKernel", "keys", "values", "_ref$bit_count", "bit_count", "_ref$check_order", "check_order", "_ref$local_shuffle", "local_shuffle", "_classPrivateMethodInitSpec", "Number", "isInteger", "prefix_block_workgroup_count", "has_values", "shaderModules", "kernels", "create_shader_modules", "create_pipelines", "remove_values", "source", "split", "filter", "line", "toLowerCase", "includes", "join", "blockSumSource", "radixSortSource_LocalShuffle", "blockSum", "reorder", "reorderSource", "create_prefix_sum_kernel", "calculate_dispatch_sizes", "create_buffers", "create_check_sort_kernels", "bit", "even", "inKeys", "tmpKeys", "inValues", "tmpValues", "outKeys", "outValues", "create_block_sum_pipeline", "reorderPipeline", "create_reorder_pipeline", "prefixBlockSumBuffer", "prefixSumKernel", "prefixSum", "prefixBlockSum", "prefixSumDispatchSize", "check_sort_fast_count", "min", "check_sort_full_count", "start_full", "dispatchSizesFast", "dispatchSizesFull", "initialDispatch", "slice", "dispatchOffsets", "radix_sort", "check_sort_fast", "prefix_sum", "tmpKeysBuffer", "tmpValuesBuffer", "localPrefixSumBuffer", "localPrefixSum", "dispatchBuffer", "INDIRECT", "originalDispatchBuffer", "checkSortFullDispatchBuffer", "checkSortFullOriginalDispatchBuffer", "isSortedBuffer", "originalDispatchSize", "checkSortFullDispatchSize", "originalCheckSortFullDispatchSize", "isSorted", "checkSortPartitionData", "checkSortFull", "checkSortFast", "initialDispatchElementCount", "console", "warn", "checkSortReset", "checkSort", "reset", "fast", "full", "_assertClassBrand", "_dispatchPipelines", "call", "_dispatchPipelinesIndirect", "_this$pipelines$i2", "getAPIImpl", "min", "max", "scale", "utils.EPSILON", "len", "angle", "cache", "getAPI", "vec2", "getVec2API", "vec3", "getVec3API", "dot", "getMat3API", "getMat4API", "getQuatAPI", "getVec4API", "particleCount", "particleCount"]
}
